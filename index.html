<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Workout Grind Tracker</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    * {
      box-sizing: border-box;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    body {
      margin: 0;
      padding: 16px;
      background: #050816;
      color: #f3f4f6;
    }
    h1, h2, h3 {
      margin-top: 0;
    }
    .app-shell {
      max-width: 1100px;
      margin: 0 auto;
    }
    .header {
      margin-bottom: 16px;
      display: flex;
      justify-content: space-between;
      gap: 12px;
      align-items: flex-end;
      flex-wrap: wrap;
    }
    .header-main {
      flex: 1;
      min-width: 220px;
    }
    .header-title {
      font-size: 1.8rem;
      font-weight: 700;
    }
    .header-subtitle {
      font-size: 0.9rem;
      color: #9ca3af;
    }
    .header-settings {
      min-width: 220px;
    }

    /* User picker */
    .user-picker {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 8px;
      flex-wrap: wrap;
    }
    .user-picker select {
      width: auto;
      min-width: 120px;
      padding: 6px 8px;
      font-size: 0.82rem;
    }
    .user-picker button {
      padding: 6px 10px;
      font-size: 0.78rem;
    }

    .grid {
      display: grid;
      grid-template-columns: minmax(0, 1.2fr) minmax(0, 1.8fr);
      gap: 16px;
    }
    @media (max-width: 800px) {
      .grid {
        grid-template-columns: minmax(0, 1fr);
      }
    }

    .card {
      background: radial-gradient(circle at top left, #1f2937, #020617);
      border-radius: 18px;
      padding: 16px;
      border: 1px solid #111827;
      box-shadow: 0 18px 40px rgba(0,0,0,0.65);
    }
    .card h2 {
      font-size: 1.05rem;
      margin-bottom: 8px;
    }

    label {
      font-size: 0.8rem;
      color: #9ca3af;
      display: block;
      margin-bottom: 4px;
    }
    input, select {
      width: 100%;
      padding: 8px;
      border-radius: 10px;
      border: 1px solid #1f2937;
      background: #020617;
      color: #f9fafb;
      font-size: 0.85rem;
      outline: none;
    }
    input:focus, select:focus {
      border-color: #38bdf8;
      box-shadow: 0 0 0 1px #0ea5e9;
    }

    .row {
      display: flex;
      gap: 8px;
      margin-bottom: 10px;
    }
    .row > div {
      flex: 1;
    }

    button {
      padding: 10px 14px;
      border-radius: 999px;
      border: none;
      background: linear-gradient(to right, #0ea5e9, #22c55e);
      color: #0b1120;
      font-weight: 600;
      cursor: pointer;
      font-size: 0.9rem;
    }
    button:hover {
      opacity: 0.9;
    }
    button.secondary {
      background: #111827;
      color: #e5e7eb;
      border: 1px solid #1f2937;
    }
    button.danger {
      background: #7f1d1d;
      color: #fca5a5;
      border: 1px solid #991b1b;
    }

    .inline-buttons {
      display: flex;
      justify-content: space-between;
      gap: 8px;
      margin-top: 8px;
      flex-wrap: wrap;
    }

    .skills-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 10px;
    }
    .skill-card {
      background: #020617;
      border-radius: 14px;
      padding: 10px;
      border: 1px solid #0f172a;
    }
    .skill-header {
      display: flex;
      justify-content: space-between;
      margin-bottom: 4px;
      gap: 4px;
    }
    .skill-name {
      font-size: 0.9rem;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 4px;
      flex-wrap: wrap;
    }
    .skill-level {
      font-size: 0.9rem;
      color: #a5b4fc;
    }
    .tier-pill {
      padding: 2px 6px;
      border-radius: 999px;
      font-size: 0.7rem;
      border: 1px solid rgba(148,163,184,0.6);
    }
    .skill-xp {
      font-size: 0.75rem;
      color: #9ca3af;
      margin-bottom: 4px;
    }
    .progress-bar {
      background: #020617;
      border-radius: 999px;
      border: 1px solid #111827;
      height: 8px;
      overflow: hidden;
    }
    .progress-fill {
      background: linear-gradient(to right, #22c55e, #84cc16);
      height: 100%;
      width: 0%;
      transition: width 1.6s cubic-bezier(0.16, 1, 0.3, 1);
    }

    .skill-level-pop {
      animation: levelUpPop 0.9s ease-out;
    }
    @keyframes levelUpPop {
      0% {
        transform: scale(1);
        filter: drop-shadow(0 0 0 rgba(248,250,252,0));
      }
      40% {
        transform: scale(1.35);
        filter: drop-shadow(0 0 14px rgba(248,250,252,0.9));
      }
      100% {
        transform: scale(1);
        filter: drop-shadow(0 0 0 rgba(248,250,252,0));
      }
    }

    .muted {
      color: #6b7280;
      font-size: 0.78rem;
    }
    .tag {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 999px;
      font-size: 0.7rem;
      border: 1px solid #1f2937;
      background: #020617;
      color: #e5e7eb;
    }

    /* Templates UI */
    .template-header {
      margin-bottom: 4px;
    }
    .template-list-title {
      font-size: 0.9rem;
      font-weight: 600;
      margin-bottom: 2px;
    }
    .template-hint {
      font-size: 0.7rem;
    }
    .template-exercises {
      margin-top: 8px;
      max-height: 200px;
      overflow-y: auto;
    }
    .template-card {
      border-radius: 10px;
      border: 1px solid #111827;
      padding: 6px 8px;
      margin-bottom: 6px;
      background: #020617;
    }
    .template-prescription {
      font-size: 0.75rem;
      color: #9ca3af;
      margin: 2px 0 2px;
    }
    .template-last {
      font-size: 0.7rem;
      color: #a5b4fc;
      margin-bottom: 4px;
    }
    .template-use-btn {
      padding: 4px 8px;
      border-radius: 999px;
      border: none;
      background: #0ea5e9;
      color: #0b1120;
      font-size: 0.7rem;
      cursor: pointer;
    }
    .template-quicklog-btn {
      padding: 4px 8px;
      border-radius: 999px;
      border: none;
      background: #22c55e;
      color: #0b1120;
      font-size: 0.7rem;
      cursor: pointer;
      margin-left: 4px;
    }

    hr {
      border: none;
      border-top: 1px solid #111827;
      margin: 10px 0;
    }

    /* History / day grouping */
    .history-day {
      border-radius: 14px;
      border: 1px solid #111827;
      padding: 8px 10px;
      margin-bottom: 8px;
      background: #020617;
    }
    .history-day-header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      margin-bottom: 4px;
    }
    .history-day-title {
      font-size: 0.9rem;
      font-weight: 600;
    }
    .history-day-sub {
      font-size: 0.7rem;
      color: #6b7280;
    }
    .history-entry {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      font-size: 0.78rem;
      padding: 2px 0;
      border-top: 1px solid #111827;
      align-items: center;
    }
    .history-entry:first-of-type {
      border-top: none;
    }
    .history-entry-main {
      flex: 2;
      min-width: 140px;
    }
    .history-entry-extra {
      flex: 1;
      min-width: 110px;
      text-align: right;
      color: #9ca3af;
      display: flex;
      align-items: center;
      justify-content: flex-end;
      gap: 6px;
    }
    .delete-entry-btn {
      background: none;
      border: none;
      color: #6b7280;
      cursor: pointer;
      font-size: 0.8rem;
      padding: 2px 4px;
      border-radius: 4px;
      line-height: 1;
    }
    .delete-entry-btn:hover {
      color: #ef4444;
      background: rgba(239,68,68,0.1);
    }

    /* History collapse */
    #historyWrapper.collapsed {
      max-height: 240px;
      overflow: hidden;
    }
    #historyWrapper.expanded {
      max-height: none;
    }
    #historyToggleBtn {
      margin-top: 4px;
      font-size: 0.75rem;
      padding: 4px 8px;
    }

    /* Tabs */
    .tabs {
      display: flex;
      gap: 6px;
      margin-bottom: 8px;
      flex-wrap: wrap;
    }
    .tab-btn {
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid #1f2937;
      background: #020617;
      color: #9ca3af;
      font-size: 0.8rem;
      cursor: pointer;
    }
    .tab-btn.active {
      background: #0ea5e9;
      color: #0b1120;
      border-color: #38bdf8;
    }

    /* Stats */
    #statsVolumeChart {
      background: #020617;
      border-radius: 10px;
      border: 1px solid #111827;
    }
    #statsSkillBars {
      background: #020617;
      border-radius: 10px;
      border: 1px solid #111827;
    }
    #statsTableWrapper table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.78rem;
    }
    #statsTableWrapper th,
    #statsTableWrapper td {
      padding: 4px;
      text-align: left;
      border-bottom: 1px solid #111827;
      white-space: nowrap;
    }
    #statsTableWrapper th {
      font-size: 0.75rem;
    }

    /* Modal overlay */
    .modal-overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.75);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    .modal-content {
      background: #1f2937;
      border-radius: 18px;
      padding: 24px;
      min-width: 300px;
      max-width: 500px;
      width: 90%;
      max-height: 90vh;
      overflow-y: auto;
      border: 1px solid #374151;
      box-shadow: 0 25px 50px rgba(0,0,0,0.5);
    }
    .modal-content h2 {
      margin-bottom: 12px;
    }
    .modal-content input, .modal-content select {
      margin-bottom: 8px;
    }
    .modal-content .row {
      margin-bottom: 6px;
    }

    /* Toast */
    .toast-bar {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: #1f2937;
      border: 1px solid #374151;
      border-radius: 14px;
      padding: 12px 20px;
      display: flex;
      align-items: center;
      gap: 12px;
      z-index: 999;
      box-shadow: 0 10px 30px rgba(0,0,0,0.5);
      font-size: 0.85rem;
      max-width: 90%;
      animation: toastSlideUp 0.3s ease-out;
    }
    @keyframes toastSlideUp {
      from { transform: translateX(-50%) translateY(20px); opacity: 0; }
      to { transform: translateX(-50%) translateY(0); opacity: 1; }
    }
    .toast-bar .toast-undo-btn {
      padding: 6px 12px;
      font-size: 0.8rem;
      border-radius: 999px;
      background: #ef4444;
      color: #fff;
      border: none;
      cursor: pointer;
      font-weight: 600;
      white-space: nowrap;
    }

    /* Streak widget */
    .streak-widget {
      display: flex;
      gap: 16px;
      margin-top: 12px;
      padding: 10px;
      background: #020617;
      border-radius: 14px;
      border: 1px solid #0f172a;
      font-size: 0.85rem;
    }
    .streak-item {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .streak-number {
      font-size: 1.4rem;
      font-weight: 700;
      color: #22c55e;
    }
    .streak-label {
      font-size: 0.7rem;
      color: #9ca3af;
    }

    /* Template builder modal exercises list */
    .tpl-builder-exercise {
      display: flex;
      gap: 6px;
      align-items: center;
      margin-bottom: 6px;
      padding: 6px;
      background: #020617;
      border-radius: 8px;
      border: 1px solid #111827;
    }
    .tpl-builder-exercise input {
      margin-bottom: 0;
    }
    .tpl-builder-exercise .remove-ex-btn {
      background: none;
      border: none;
      color: #ef4444;
      cursor: pointer;
      font-size: 1rem;
      padding: 2px 6px;
      flex-shrink: 0;
    }

    /* Export/Import area */
    .settings-section {
      margin-top: 10px;
      padding-top: 8px;
      border-top: 1px solid #111827;
    }
    .settings-section .inline-buttons {
      margin-top: 4px;
    }
  </style>
</head>
<body>
  <div class="app-shell">
    <div class="header">
      <div class="header-main">
        <div class="header-title">Workout Grind Tracker</div>
        <div class="header-subtitle">
          Legs / Push / Pull / Core / Cardio / Flexibility &rarr; XP &rarr; Level 100 is Max.
        </div>
        <div class="user-picker">
          <label for="userSelect" style="margin-bottom:0; white-space:nowrap;">User:</label>
          <select id="userSelect"></select>
          <button type="button" class="secondary" id="addUserBtn">+ New user</button>
        </div>
      </div>
      <div class="header-settings card" style="padding:10px 12px; border-radius:14px;">
        <label for="bodyweightInput">Bodyweight (lb)</label>
        <input type="number" id="bodyweightInput" min="50" max="400" step="1" />
        <div class="muted" style="margin-top:2px;font-size:0.7rem;">
          Used to estimate load for bodyweight movements (push-ups, pull-ups, dips, etc).
        </div>
        <div id="cloudStatus" class="muted" style="margin-top:4px;font-size:0.7rem;"></div>
        <div class="settings-section">
          <div class="muted" style="font-size:0.7rem;">Data management</div>
          <div class="inline-buttons">
            <button type="button" class="secondary" id="exportBtn" style="font-size:0.75rem;padding:6px 10px;">Export JSON</button>
            <button type="button" class="secondary" id="importBtn" style="font-size:0.75rem;padding:6px 10px;">Import JSON</button>
          </div>
          <input type="file" id="importFileInput" accept=".json" style="display:none;" />
        </div>
      </div>
    </div>

    <div class="grid">
      <!-- Left: plan + log -->
      <div class="card">
        <h2>Today&apos;s plan & log</h2>

        <!-- Plan / templates -->
        <div class="template-header">
          <div class="template-list-title">Pick a routine</div>
          <div class="template-hint muted">
            Choose a split, then tap an exercise to fill the form with your last values.
          </div>
        </div>
        <div class="row">
          <div>
            <label for="templateSelect">Workout template</label>
            <select id="templateSelect"></select>
          </div>
        </div>
        <div id="templateExercises" class="template-exercises"></div>

        <hr />

        <!-- Log form -->
        <form id="logForm">
          <div class="row">
            <div>
              <label for="dateInput">Date</label>
              <input type="date" id="dateInput" required />
            </div>
            <div>
              <label for="workoutInput">Workout name (optional)</label>
              <input type="text" id="workoutInput" placeholder="Chest & Tricep 1" />
            </div>
          </div>

          <div class="row">
            <div>
              <label for="skillInput">Skill</label>
              <select id="skillInput">
                <option value="Legs">Legs</option>
                <option value="Push">Push</option>
                <option value="Pull">Pull</option>
                <option value="Core">Core</option>
                <option value="Cardio">Cardio</option>
                <option value="Flexibility">Flexibility</option>
                <option value="Custom">Custom&hellip;</option>
              </select>
            </div>
            <div id="customSkillWrapper" style="display:none;">
              <label for="customSkillInput">Custom skill name</label>
              <input type="text" id="customSkillInput" placeholder="e.g. Mobility" />
            </div>
          </div>

          <!-- Strength / Flex row -->
          <div class="row" id="rowStrength">
            <div>
              <label for="setsInput">Sets</label>
              <input type="number" id="setsInput" min="1" step="1" />
            </div>
            <div>
              <label for="repsInput">Reps per set</label>
              <input type="number" id="repsInput" min="1" step="1" />
            </div>
            <div id="weightContainer">
              <label for="weightInput">Weight (lb)</label>
              <input type="number" id="weightInput" min="0" step="0.5" />
            </div>
          </div>

          <!-- Cardio row -->
          <div class="row" id="rowCardio" style="display:none;">
            <div>
              <label for="cardioModeSelect">Cardio input</label>
              <select id="cardioModeSelect">
                <option value="speed">Speed &times; time</option>
                <option value="distance">Distance &times; time</option>
                <option value="speeddist">Speed &times; distance</option>
              </select>
            </div>
            <div>
              <label id="cardioValueLabel" for="cardioValueInput">Speed (mph)</label>
              <input type="number" id="cardioValueInput" min="0" step="0.1" />
            </div>
            <div id="cardioTimeContainer">
              <label id="cardioSecondLabel" for="cardioMinutesInput">Time (minutes)</label>
              <input type="number" id="cardioMinutesInput" min="0" step="0.1" />
            </div>
          </div>

          <div class="row">
            <div>
              <label for="exerciseInput">Exercise</label>
              <input type="text" id="exerciseInput" placeholder="Bench press / Run" required />
            </div>
          </div>

          <div class="row">
            <div>
              <label>Volume (auto)</label>
              <input type="text" id="volumePreview" disabled />
            </div>
            <div>
              <label>XP (auto)</label>
              <input type="text" id="xpPreview" disabled />
            </div>
          </div>

          <div class="inline-buttons">
            <button type="submit">Add entry</button>
            <button type="button" class="secondary" id="clearAllBtn">Clear my data (local)</button>
          </div>
        </form>
      </div>

      <!-- Right: skills + history / stats -->
      <div class="card">
        <h2>Skills</h2>
        <div class="tabs">
          <button type="button" class="tab-btn active" id="tabOverviewBtn">Overview</button>
          <button type="button" class="tab-btn" id="tabStatsBtn">Stats</button>
        </div>

        <!-- Overview pane -->
        <div id="overviewPane">
          <div id="skillsContainer" class="skills-grid"></div>

          <div id="streakWidget" class="streak-widget" style="display:none;">
            <div class="streak-item">
              <div class="streak-number" id="currentStreakNum">0</div>
              <div class="streak-label">Current streak (days)</div>
            </div>
            <div class="streak-item">
              <div class="streak-number" id="longestStreakNum">0</div>
              <div class="streak-label">Longest streak (days)</div>
            </div>
          </div>

          <h3 style="margin-top:16px; font-size:0.95rem;">Workout history</h3>
          <div id="historyWrapper" class="collapsed">
            <div id="historyContainer"></div>
            <div id="emptyState" class="muted" style="margin-top:4px;">
              No workouts logged yet.
            </div>
          </div>
          <button type="button" class="secondary" id="historyToggleBtn">Show all history</button>
        </div>

        <!-- Stats pane -->
        <div id="statsPane" style="display:none;">
          <h3 style="font-size:0.95rem; margin-bottom:6px;">Skill XP overview</h3>
          <div id="statsSkillBarsWrapper" style="margin-bottom:10px;">
            <svg id="statsSkillBars" viewBox="0 0 320 140" preserveAspectRatio="none" style="width:100%; height:140px;"></svg>
          </div>

          <h3 style="font-size:0.95rem; margin-bottom:6px;">Exercise progress</h3>
          <div class="row">
            <div>
              <label for="statsExerciseSelect">Exercise</label>
              <select id="statsExerciseSelect"></select>
            </div>
          </div>
          <div id="statsExerciseSummary" class="muted" style="margin-bottom:6px;"></div>
          <div id="statsChartWrapper">
            <svg id="statsVolumeChart" viewBox="0 0 320 140" preserveAspectRatio="none" style="width:100%; height:140px;"></svg>
          </div>
          <div id="statsTableWrapper" style="margin-top:8px;"></div>
        </div>
      </div>
    </div>
  </div>

<script>
  // ===== CONFIG =====
  const SERVER_URL = "https://script.google.com/macros/s/AKfycbzRn7xYTMPzIfJctWIaLGypQPuhJXnnEmhsuo5w32uSnEFuboM0HoauUUCE-ei9rCrS/exec";

  const LOCAL_ENTRIES_KEY = "workoutGrindEntries_v3";
  const LOCAL_SETTINGS_KEY = "workoutGrindSettings_v1";
  const LOCAL_CUSTOM_TEMPLATES_KEY = "workoutGrindCustomTemplates_v1";
  const LOCAL_DELETED_IDS_KEY = "workoutGrindDeletedIds_v1";

  const USER_CURRENT_KEY = "workoutGrind_currentUser";
  const USER_KNOWN_KEY = "workoutGrind_knownUsers";

  const MAX_LEVEL = 100;
  const XP_SCALE = 5;
  const BASE_XP_PER_MILE = 25;
  const REF_PACE_MIN_PER_MILE = 10;

  // ===== Multi-User =====
  let currentUser = "";

  function getKnownUsers() {
    try {
      const raw = localStorage.getItem(USER_KNOWN_KEY);
      if (!raw) return [];
      const arr = JSON.parse(raw);
      return Array.isArray(arr) ? arr : [];
    } catch { return []; }
  }

  function saveKnownUsers(users) {
    localStorage.setItem(USER_KNOWN_KEY, JSON.stringify(users));
  }

  function getUserKey(baseKey) {
    return baseKey + "__" + currentUser;
  }

  function hasLegacyData() {
    return localStorage.getItem(LOCAL_ENTRIES_KEY) !== null ||
           localStorage.getItem(LOCAL_SETTINGS_KEY) !== null;
  }

  function migrateLegacyData(username) {
    const oldEntries = localStorage.getItem(LOCAL_ENTRIES_KEY);
    const oldSettings = localStorage.getItem(LOCAL_SETTINGS_KEY);
    const oldTemplates = localStorage.getItem(LOCAL_CUSTOM_TEMPLATES_KEY);

    if (oldEntries !== null) {
      localStorage.setItem(LOCAL_ENTRIES_KEY + "__" + username, oldEntries);
      localStorage.removeItem(LOCAL_ENTRIES_KEY);
    }
    if (oldSettings !== null) {
      localStorage.setItem(LOCAL_SETTINGS_KEY + "__" + username, oldSettings);
      localStorage.removeItem(LOCAL_SETTINGS_KEY);
    }
    if (oldTemplates !== null) {
      localStorage.setItem(LOCAL_CUSTOM_TEMPLATES_KEY + "__" + username, oldTemplates);
      localStorage.removeItem(LOCAL_CUSTOM_TEMPLATES_KEY);
    }
  }

  // ===== Exercise-to-skill auto-mapping =====
  const EXERCISE_SKILL_MAP = {
    // Push exercises
    "bench press": "Push", "dumbbell bench": "Push", "incline bench": "Push", "decline bench": "Push",
    "push-ups": "Push", "push ups": "Push", "diamond push-ups": "Push", "diamond push ups": "Push",
    "dips": "Push", "tricep pull downs": "Push", "tricep pulldowns": "Push", "tricep pushdowns": "Push",
    "tricep extensions": "Push", "skull crushers": "Push", "skullcrushers": "Push",
    "overhead press": "Push", "shoulder press": "Push", "military press": "Push",
    "dumbbell flies": "Push", "dumbbell flyes": "Push", "chest flies": "Push", "chest flyes": "Push",
    "pec crossovers": "Push", "cable crossovers": "Push", "pec deck": "Push",
    "lat push down": "Push", "lateral raise": "Push", "lateral raise machine": "Push",
    "delt raises": "Push", "delts/floor t-raise": "Push", "front raise": "Push",
    "hollow body negatives": "Push",
    // Pull exercises
    "pull ups": "Pull", "pull-ups": "Pull", "chin ups": "Pull", "chin-ups": "Pull",
    "rows": "Pull", "single arm rows": "Pull", "barbell rows": "Pull", "dumbbell rows": "Pull",
    "cable rows": "Pull", "seated rows": "Pull", "bent over rows": "Pull",
    "pull down bar": "Pull", "lat pulldown": "Pull", "lat pulldowns": "Pull",
    "face pulls": "Pull", "curls": "Pull", "bicep curls": "Pull", "hammer curls": "Pull",
    "preacher curls": "Pull", "upright trap row": "Pull", "upright row": "Pull",
    "rear delt machine": "Pull", "rear shoulder dumbbell raises": "Pull",
    "rear delt flies": "Pull", "rear delt flyes": "Pull",
    "deadlift": "Pull", "deadlifts": "Pull",
    // Legs exercises
    "squats": "Legs", "squat": "Legs", "goblet squats": "Legs", "front squats": "Legs",
    "back squats": "Legs", "bulgarian squats": "Legs", "bulgarian split squats": "Legs",
    "lunges": "Legs", "dumbbell lunge": "Legs", "dumbbell lunges": "Legs",
    "walking lunges": "Legs", "reverse lunges": "Legs",
    "leg press": "Legs", "leg extension": "Legs", "leg extensions": "Legs",
    "leg curl": "Legs", "leg curls": "Legs", "hamstring curls": "Legs",
    "hip thrusts": "Legs", "hip thrust": "Legs", "glute bridge": "Legs", "glute bridges": "Legs",
    "cable kick back": "Legs", "cable kickback": "Legs", "cable kickbacks": "Legs",
    "calf raises": "Legs", "calf raise": "Legs",
    "step ups": "Legs", "step-ups": "Legs",
    "rdl": "Legs", "romanian deadlift": "Legs",
    // Core exercises
    "crunches": "Core", "crunch": "Core", "sit ups": "Core", "sit-ups": "Core",
    "planks": "Core", "plank": "Core", "side plank": "Core",
    "v-ups": "Core", "toe touch crunch": "Core", "side crunch": "Core",
    "wipers": "Core", "russian twists": "Core", "russian twist": "Core",
    "leg raises": "Core", "hanging leg raises": "Core",
    "bicycle crunches": "Core", "mountain climbers": "Core",
    "ab wheel": "Core", "ab rollout": "Core",
    // Cardio exercises
    "run": "Cardio", "running": "Cardio", "jog": "Cardio", "jogging": "Cardio",
    "sprint": "Cardio", "sprints": "Cardio",
    "bike": "Cardio", "cycling": "Cardio", "biking": "Cardio",
    "swim": "Cardio", "swimming": "Cardio",
    "rowing": "Cardio", "row machine": "Cardio", "erg": "Cardio",
    "jump rope": "Cardio", "jumping jacks": "Cardio",
    "elliptical": "Cardio", "stairmaster": "Cardio", "stairs": "Cardio",
    "walk": "Cardio", "walking": "Cardio", "hike": "Cardio", "hiking": "Cardio",
    // Flexibility exercises
    "stretch": "Flexibility", "stretching": "Flexibility",
    "static stretch worked muscles": "Flexibility",
    "yoga": "Flexibility", "foam roll": "Flexibility", "foam rolling": "Flexibility",
    "mobility": "Flexibility"
  };

  function getSkillForExercise(exerciseName, fallbackSkill) {
    if (!exerciseName) return fallbackSkill || "Push";
    const name = exerciseName.toLowerCase().trim();
    // Exact match first
    if (EXERCISE_SKILL_MAP[name]) return EXERCISE_SKILL_MAP[name];
    // Partial match: check if any key is contained in the exercise name
    for (const [key, skill] of Object.entries(EXERCISE_SKILL_MAP)) {
      if (name.includes(key)) return skill;
    }
    return fallbackSkill || "Push";
  }

  // ===== Hidden default templates tracking =====
  const LOCAL_HIDDEN_DEFAULTS_KEY = "workoutGrindHiddenDefaults_v1";

  function loadHiddenDefaults() {
    try {
      const raw = localStorage.getItem(getUserKey(LOCAL_HIDDEN_DEFAULTS_KEY));
      return raw ? JSON.parse(raw) : [];
    } catch { return []; }
  }

  function saveHiddenDefaults(arr) {
    localStorage.setItem(getUserKey(LOCAL_HIDDEN_DEFAULTS_KEY), JSON.stringify(arr));
  }

  let hiddenDefaults = [];

  // ===== Templates =====
  const defaultTemplates = [
    {
      name: "Chest & Tricep 1",
      defaultSkill: "Push",
      exercises: [
        { name: "Bench press", prescription: "4x5x135", skill: "Push" },
        { name: "Diamond push-ups", prescription: "3x10xBW", skill: "Push" },
        { name: "Tricep pull downs", prescription: "3x10x7", skill: "Push" },
        { name: "Lat push down", prescription: "3x10x3", skill: "Push" },
        { name: "Hollow body negatives", prescription: "3x5xBW", skill: "Push" },
        { name: "Delts/Floor T-Raise", prescription: "3x10x10", skill: "Push" },
        { name: "Run", prescription: "cardio:6.5x15", skill: "Cardio" },
        { name: "Static stretch worked muscles", prescription: "flex:3x10", skill: "Flexibility" }
      ]
    },
    {
      name: "Back & Bicep & Delt 1",
      defaultSkill: "Pull",
      exercises: [
        { name: "Pull ups", prescription: "3x10xBW", skill: "Pull" },
        { name: "Single arm rows", prescription: "3x10x50", skill: "Pull" },
        { name: "Upright trap row", prescription: "3x10x3", skill: "Pull" },
        { name: "Lateral raise machine", prescription: "3x10x1", skill: "Push" },
        { name: "Rear delt machine", prescription: "3x10x2", skill: "Pull" },
        { name: "V-ups", prescription: "3x10xBW", skill: "Core" },
        { name: "Run", prescription: "cardio:6.5x10", skill: "Cardio" },
        { name: "Static stretch worked muscles", prescription: "flex:3x10", skill: "Flexibility" }
      ]
    },
    {
      name: "Legs & Glute 1",
      defaultSkill: "Legs",
      exercises: [
        { name: "Hip thrusts", prescription: "3x10x155", skill: "Legs" },
        { name: "Bulgarian squats", prescription: "3x10x30", skill: "Legs" },
        { name: "Dumbbell lunge", prescription: "3x10x30", skill: "Legs" },
        { name: "Cable kick back", prescription: "3x10x6", skill: "Legs" },
        { name: "Toe touch crunch", prescription: "3x25xBW", skill: "Core" },
        { name: "Delts/Floor T-Raise", prescription: "3x10x10", skill: "Push" },
        { name: "Run", prescription: "cardio:6.5x12.5", skill: "Cardio" },
        { name: "Static stretch worked muscles", prescription: "flex:3x10", skill: "Flexibility" }
      ]
    },
    {
      name: "Chest & Tricep 2",
      defaultSkill: "Push",
      exercises: [
        { name: "Dips", prescription: "3x10xBW", skill: "Push" },
        { name: "Dumbbell flies", prescription: "3x10x40", skill: "Push" },
        { name: "Skullcrushers", prescription: "3x10x30", skill: "Push" },
        { name: "Pec crossovers", prescription: "3x10x3", skill: "Push" },
        { name: "Side crunch", prescription: "3x10xBW", skill: "Core" },
        { name: "Delts/Floor T-Raise", prescription: "3x10x15", skill: "Push" },
        { name: "Run", prescription: "cardio:6.5x10", skill: "Cardio" },
        { name: "Static stretch worked muscles", prescription: "flex:3x10", skill: "Flexibility" }
      ]
    },
    {
      name: "Back & Bicep & Delt 2",
      defaultSkill: "Pull",
      exercises: [
        { name: "Chin ups", prescription: "3x5xBW", skill: "Pull" },
        { name: "Pull down bar", prescription: "3x10x110", skill: "Pull" },
        { name: "Face pulls", prescription: "3x10x55", skill: "Pull" },
        { name: "Curls", prescription: "3x10x25", skill: "Pull" },
        { name: "Rear shoulder dumbbell raises", prescription: "3x10x15", skill: "Pull" },
        { name: "Wipers", prescription: "3x10xBW", skill: "Core" },
        { name: "Run", prescription: "cardio:6.5x5", skill: "Cardio" },
        { name: "Static stretch worked muscles", prescription: "flex:3x10", skill: "Flexibility" }
      ]
    },
    {
      name: "Everything Workout",
      defaultSkill: "Pull",
      exercises: [
        { name: "Chin ups", prescription: "3x10xBW", skill: "Pull" },
        { name: "Push ups", prescription: "3x10xBW", skill: "Push" },
        { name: "Goblet squats", prescription: "3x10x50", skill: "Legs" },
        { name: "Delt raises", prescription: "3x10x15", skill: "Push" },
        { name: "Run", prescription: "cardio:6.5x15", skill: "Cardio" }
      ]
    }
  ];

  // ===== Tiers =====
  function getTierInfo(level) {
    if (level >= 91) return { name: "Apex Predator", color: "#ef4444" };
    if (level >= 81) return { name: "Legend", color: "#fbbf24" };
    if (level >= 71) return { name: "Champion", color: "#ec4899" };
    if (level >= 61) return { name: "Master", color: "#a855f7" };
    if (level >= 51) return { name: "Diamond", color: "#2563eb" };
    if (level >= 41) return { name: "Platinum", color: "#22d3ee" };
    if (level >= 31) return { name: "Gold", color: "#facc15" };
    if (level >= 21) return { name: "Silver", color: "#9ca3af" };
    if (level >= 11) return { name: "Bronze", color: "#b45309" };
    return { name: "Rookie", color: "#92400e" };
  }

  // ===== Level curve =====
  function totalXpForLevel(level) {
    const n = Math.max(0, level - 1);
    return XP_SCALE * n * n;
  }

  function getLevelFromXp(xp) {
    let lvl = 1;
    for (let i = 2; i <= MAX_LEVEL; i++) {
      if (xp >= totalXpForLevel(i)) {
        lvl = i;
      } else {
        break;
      }
    }
    return lvl;
  }

  function inferSkillType(skillName) {
    const s = (skillName || "").toLowerCase();
    if (s === "cardio") return "cardio";
    if (s === "flexibility") return "flexibility";
    return "strength";
  }

  // ===== Storage (per-user namespaced) =====
  function loadSettings() {
    try {
      const raw = localStorage.getItem(getUserKey(LOCAL_SETTINGS_KEY));
      if (!raw) return { bodyweight: 180 };
      const s = JSON.parse(raw);
      if (!s || typeof s !== "object") return { bodyweight: 180 };
      if (!s.bodyweight || s.bodyweight <= 0) s.bodyweight = 180;
      return s;
    } catch {
      return { bodyweight: 180 };
    }
  }

  function saveSettings(settings) {
    localStorage.setItem(getUserKey(LOCAL_SETTINGS_KEY), JSON.stringify(settings));
  }

  function loadEntriesLocal() {
    try {
      const raw = localStorage.getItem(getUserKey(LOCAL_ENTRIES_KEY));
      if (!raw) return [];
      const arr = JSON.parse(raw);
      return Array.isArray(arr) ? arr : [];
    } catch {
      return [];
    }
  }

  function saveEntriesLocal(entries) {
    localStorage.setItem(getUserKey(LOCAL_ENTRIES_KEY), JSON.stringify(entries));
  }

  function loadCustomTemplates() {
    try {
      const raw = localStorage.getItem(getUserKey(LOCAL_CUSTOM_TEMPLATES_KEY));
      if (!raw) return [];
      const arr = JSON.parse(raw);
      return Array.isArray(arr) ? arr : [];
    } catch {
      return [];
    }
  }

  function saveCustomTemplates(templates) {
    localStorage.setItem(getUserKey(LOCAL_CUSTOM_TEMPLATES_KEY), JSON.stringify(templates));
  }

  function loadDeletedIds() {
    try {
      const raw = localStorage.getItem(getUserKey(LOCAL_DELETED_IDS_KEY));
      if (!raw) return [];
      const arr = JSON.parse(raw);
      return Array.isArray(arr) ? arr : [];
    } catch {
      return [];
    }
  }

  function saveDeletedIds(ids) {
    localStorage.setItem(getUserKey(LOCAL_DELETED_IDS_KEY), JSON.stringify(ids));
  }

  function normalizeEntryFromServer(raw) {
    return {
      id: Number(raw.id) || Date.now(),
      date: raw.date || "",
      workout: raw.workout || "",
      skill: raw.skill || "",
      skillType: raw.skillType || inferSkillType(raw.skill),
      exercise: raw.exercise || "",
      sets: Number(raw.sets) || 0,
      reps: Number(raw.reps) || 0,
      weight: Number(raw.weight) || 0,
      speed: Number(raw.speed) || 0,
      minutes: Number(raw.minutes) || 0,
      volume: Number(raw.volume) || 0,
      xp: Number(raw.xp) || 0,
      cardioMode: raw.cardioMode || null,
      user: raw.user || ""
    };
  }

  async function fetchEntriesFromServer() {
    if (!SERVER_URL) return null;
    setCloudStatus("Cloud sync: connecting...");
    try {
      const res = await fetch(SERVER_URL + "?mode=list");
      if (!res.ok) throw new Error("Server error");
      const data = await res.json();
      if (!Array.isArray(data)) {
        setCloudStatus("Cloud sync: local only (bad data from server)");
        return null;
      }
      setCloudStatus("Cloud sync: connected");
      const all = data.map(normalizeEntryFromServer);
      // Filter to current user's entries and legacy entries (no user field)
      return all.filter(e => e.user === currentUser || e.user === "");
    } catch (err) {
      console.error(err);
      setCloudStatus("Cloud sync: local only (could not reach server)");
      return null;
    }
  }

  // ===== Server writes =====
  async function saveEntryToServer(entry) {
    if (!SERVER_URL) return;
    try {
      const res = await fetch(SERVER_URL, {
        method: "POST",
        headers: { "Content-Type": "text/plain;charset=utf-8" },
        body: JSON.stringify({ mode: "add", entry })
      });
      if (!res.ok) {
        console.error("Server error when saving entry", res.status, await res.text());
        setCloudStatus("Cloud sync: error (server)");
      } else {
        setCloudStatus("Cloud sync: connected");
      }
    } catch (err) {
      console.error(err);
      setCloudStatus("Cloud sync: error (saving locally only)");
    }
  }

  async function clearServerEntries() {
    if (!SERVER_URL) return;
    try {
      const res = await fetch(SERVER_URL, {
        method: "POST",
        headers: { "Content-Type": "text/plain;charset=utf-8" },
        body: JSON.stringify({ mode: "clear" })
      });
      if (!res.ok) {
        console.error("Server error when clearing entries", res.status, await res.text());
        setCloudStatus("Cloud sync: error clearing server data");
      } else {
        setCloudStatus("Cloud sync: connected");
      }
    } catch (err) {
      console.error(err);
      setCloudStatus("Cloud sync: error clearing server data");
    }
  }

  function setCloudStatus(text) {
    if (cloudStatusEl) cloudStatusEl.textContent = text;
  }

  // ===== XP & volume =====
  function getSkillTypeFromSelectValue(val) {
    if (val === "Cardio") return "cardio";
    if (val === "Flexibility") return "flexibility";
    return "strength";
  }

  function estimateBodyweightLoad(exerciseName, bodyweight) {
    const name = (exerciseName || "").toLowerCase();
    if (name.includes("push-up") || name.includes("push up")) return bodyweight * 0.6;
    if (name.includes("pull up") || name.includes("chin up")) return bodyweight * 1.0;
    if (name.includes("dip")) return bodyweight * 0.9;
    if (name.includes("row")) return bodyweight * 0.7;
    return bodyweight * 0.7;
  }

  function computeVolumeAndXp(
    skillType, sets, reps, weight, speedOrDistance, minutes,
    exerciseName, bodyweight, cardioMode
  ) {
    let volume = 0;
    let xp = 0;

    if (skillType === "cardio") {
      const mode = cardioMode || "speed";
      let distanceMiles = 0;
      let effectiveMinutes = minutes;
      if (mode === "distance") {
        distanceMiles = speedOrDistance;
      } else if (mode === "speeddist") {
        // speedOrDistance = speed (mph), minutes = distance (miles)
        const speed = speedOrDistance;
        distanceMiles = minutes;
        effectiveMinutes = speed > 0 ? (distanceMiles / speed) * 60 : 0;
      } else {
        distanceMiles = speedOrDistance * (minutes / 60);
      }
      volume = distanceMiles;

      if (distanceMiles > 0) {
        let intensityMultiplier = 1;
        if (effectiveMinutes > 0) {
          const pace = effectiveMinutes / distanceMiles;
          let ratio = REF_PACE_MIN_PER_MILE / pace;
          if (!isFinite(ratio) || ratio <= 0) ratio = 1;
          intensityMultiplier = Math.sqrt(ratio);
          if (intensityMultiplier < 0.7) intensityMultiplier = 0.7;
          if (intensityMultiplier > 1.5) intensityMultiplier = 1.5;
        }
        xp = Math.round(distanceMiles * BASE_XP_PER_MILE * intensityMultiplier);
      }
    } else if (skillType === "flexibility") {
      volume = sets * reps;
      xp = volume > 0 ? Math.round(volume * 0.2) : 0;
    } else {
      let effectiveWeight = weight;
      if (!effectiveWeight || effectiveWeight <= 0) {
        effectiveWeight = estimateBodyweightLoad(exerciseName, bodyweight);
      }
      volume = sets * reps * effectiveWeight;
      xp = volume > 0 ? Math.round(volume / 220) : 0;
    }
    return { volume, xp };
  }

  function recalcEntriesUsingCurrentFormulas(entriesArr) {
    for (const e of entriesArr) {
      const skillType = e.skillType || inferSkillType(e.skill);
      let cardioMode = e.cardioMode || null;
      if (skillType === "cardio") {
        if (!cardioMode) {
          if (e.minutes > 0 && e.speed > 0 && e.speed <= 30) {
            cardioMode = "speed";
          } else {
            cardioMode = "distance";
          }
        }
      }

      const { volume, xp } = computeVolumeAndXp(
        skillType, e.sets || 0, e.reps || 0, e.weight || 0,
        e.speed || 0, e.minutes || 0, e.exercise || "",
        settings.bodyweight, cardioMode
      );

      e.skillType = skillType;
      e.volume = volume;
      e.xp = xp;
      if (cardioMode && skillType === "cardio") e.cardioMode = cardioMode;
    }
  }

  // ===== Prescription parsers =====
  function parseStrengthPrescription(prescription) {
    if (!prescription) return null;
    const m = prescription.match(/^\s*(\d+)\s*x\s*(\d+)\s*x\s*([0-9.]+|BW)\s*$/i);
    if (!m) return null;
    const sets = parseInt(m[1], 10);
    const reps = parseInt(m[2], 10);
    let weight = null;
    if (m[3].toUpperCase() !== "BW") {
      weight = parseFloat(m[3]);
    }
    if (!Number.isFinite(sets) || !Number.isFinite(reps)) return null;
    return { sets, reps, weight };
  }

  function parseCardioPrescription(prescription) {
    if (!prescription || !prescription.startsWith("cardio:")) return null;
    const rest = prescription.slice(7);
    const m = rest.match(/^\s*([0-9.]+)\s*x\s*([0-9.]+)\s*$/);
    if (!m) return null;
    const speed = parseFloat(m[1]);
    const minutes = parseFloat(m[2]);
    if (!Number.isFinite(speed) || !Number.isFinite(minutes)) return null;
    return { speed, minutes };
  }

  function parseFlexPrescription(prescription) {
    if (!prescription || !prescription.startsWith("flex:")) return null;
    const rest = prescription.slice(5);
    const m = rest.match(/^\s*(\d+)\s*x\s*(\d+)\s*$/);
    if (!m) return null;
    const sets = parseInt(m[1], 10);
    const reps = parseInt(m[2], 10);
    if (!Number.isFinite(sets) || !Number.isFinite(reps)) return null;
    return { sets, reps };
  }

  function formatEntryDetails(e) {
    if (!e) return "";

    if (e.skillType === "cardio") {
      const mode = e.cardioMode || (e.minutes > 0 ? "speed" : "distance");
      if (mode === "speeddist") {
        return `${e.speed} mph × ${e.minutes} mi`;
      }
      if (e.minutes > 0) {
        if (mode === "distance") {
          return `${e.speed} mi in ${e.minutes} min`;
        }
        return `${e.speed} mph × ${e.minutes} min`;
      }
      if (mode === "distance") {
        return `${e.speed} mi`;
      }
      return `${e.speed} mph`;
    }

    if (e.skillType === "flexibility") {
      return `${e.sets} × ${e.reps}`;
    }

    if (e.weight > 0) {
      return `${e.sets} × ${e.reps} × ${e.weight}`;
    }

    return `${e.sets} × ${e.reps} × BW`;
  }

  // ===== DOM refs =====
  const dateInput = document.getElementById("dateInput");
  const workoutInput = document.getElementById("workoutInput");
  const skillInput = document.getElementById("skillInput");
  const customSkillWrapper = document.getElementById("customSkillWrapper");
  const customSkillInput = document.getElementById("customSkillInput");
  const setsInput = document.getElementById("setsInput");
  const repsInput = document.getElementById("repsInput");
  const weightInput = document.getElementById("weightInput");
  const weightContainer = document.getElementById("weightContainer");

  const rowStrength = document.getElementById("rowStrength");
  const rowCardio = document.getElementById("rowCardio");
  const cardioModeSelect = document.getElementById("cardioModeSelect");
  const cardioValueLabel = document.getElementById("cardioValueLabel");
  const cardioValueInput = document.getElementById("cardioValueInput");
  const cardioMinutesInput = document.getElementById("cardioMinutesInput");
  const cardioTimeContainer = document.getElementById("cardioTimeContainer");

  const exerciseInput = document.getElementById("exerciseInput");
  const volumePreview = document.getElementById("volumePreview");
  const xpPreview = document.getElementById("xpPreview");
  const logForm = document.getElementById("logForm");
  const skillsContainer = document.getElementById("skillsContainer");
  const historyWrapper = document.getElementById("historyWrapper");
  const historyContainer = document.getElementById("historyContainer");
  const historyToggleBtn = document.getElementById("historyToggleBtn");
  const emptyState = document.getElementById("emptyState");
  const clearAllBtn = document.getElementById("clearAllBtn");
  const templateSelect = document.getElementById("templateSelect");
  const templateExercisesDiv = document.getElementById("templateExercises");
  const bodyweightInput = document.getElementById("bodyweightInput");
  const cloudStatusEl = document.getElementById("cloudStatus");

  const tabOverviewBtn = document.getElementById("tabOverviewBtn");
  const tabStatsBtn = document.getElementById("tabStatsBtn");
  const overviewPane = document.getElementById("overviewPane");
  const statsPane = document.getElementById("statsPane");
  const statsExerciseSelect = document.getElementById("statsExerciseSelect");
  const statsExerciseSummary = document.getElementById("statsExerciseSummary");
  const statsVolumeChart = document.getElementById("statsVolumeChart");
  const statsTableWrapper = document.getElementById("statsTableWrapper");
  const statsSkillBars = document.getElementById("statsSkillBars");

  const userSelect = document.getElementById("userSelect");
  const addUserBtn = document.getElementById("addUserBtn");
  const exportBtn = document.getElementById("exportBtn");
  const importBtn = document.getElementById("importBtn");
  const importFileInput = document.getElementById("importFileInput");
  const streakWidget = document.getElementById("streakWidget");
  const currentStreakNum = document.getElementById("currentStreakNum");
  const longestStreakNum = document.getElementById("longestStreakNum");

  // ===== runtime state =====
  const entries = [];
  let deletedIds = [];
  let customTemplates = [];
  let lastByExercise = {};
  let settings = { bodyweight: 180 };
  let prevSkillTotals = {};
  let prevSkillLevels = {};
  let hasRenderedSkillsOnce = false;
  let historyExpanded = false;
  let toastTimeout = null;

  dateInput.valueAsNumber = Date.now() - new Date().getTimezoneOffset() * 60000;

  if (!SERVER_URL) {
    setCloudStatus("Cloud sync: off (local only)");
  }

  // ===== User picker =====
  function populateUserSelect() {
    const users = getKnownUsers();
    userSelect.innerHTML = "";
    users.forEach(u => {
      const opt = document.createElement("option");
      opt.value = u;
      opt.textContent = u;
      if (u === currentUser) opt.selected = true;
      userSelect.appendChild(opt);
    });
  }

  userSelect.addEventListener("change", () => {
    const selected = userSelect.value;
    if (selected && selected !== currentUser) {
      currentUser = selected;
      localStorage.setItem(USER_CURRENT_KEY, currentUser);
      reloadForCurrentUser();
    }
  });

  addUserBtn.addEventListener("click", () => {
    showNewUserModal(false);
  });

  function showNewUserModal(isFirstTime) {
    const overlay = document.createElement("div");
    overlay.className = "modal-overlay";
    overlay.innerHTML = `
      <div class="modal-content">
        <h2>${isFirstTime ? "Welcome! Enter your name" : "Add new user"}</h2>
        <label for="modalNameInput">Your name</label>
        <input type="text" id="modalNameInput" placeholder="e.g. Alice" autofocus />
        <div style="margin-top:12px; display:flex; gap:8px;">
          <button type="button" id="modalConfirmBtn">Confirm</button>
          ${isFirstTime ? "" : '<button type="button" class="secondary" id="modalCancelBtn">Cancel</button>'}
        </div>
      </div>
    `;
    document.body.appendChild(overlay);

    const nameInput = overlay.querySelector("#modalNameInput");
    const confirmBtn = overlay.querySelector("#modalConfirmBtn");
    const cancelBtn = overlay.querySelector("#modalCancelBtn");

    nameInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") confirmBtn.click();
    });

    confirmBtn.addEventListener("click", () => {
      const name = nameInput.value.trim();
      if (!name) {
        nameInput.style.borderColor = "#ef4444";
        return;
      }
      const users = getKnownUsers();
      if (!users.includes(name)) {
        users.push(name);
        saveKnownUsers(users);
      }

      // If first time and legacy data exists, migrate it
      if (isFirstTime && hasLegacyData()) {
        migrateLegacyData(name);
      }

      currentUser = name;
      localStorage.setItem(USER_CURRENT_KEY, currentUser);
      overlay.remove();
      populateUserSelect();
      reloadForCurrentUser();
    });

    if (cancelBtn) {
      cancelBtn.addEventListener("click", () => {
        overlay.remove();
      });
    }
  }

  function reloadForCurrentUser() {
    // Reset runtime state
    entries.splice(0, entries.length);
    lastByExercise = {};
    prevSkillTotals = {};
    prevSkillLevels = {};
    hasRenderedSkillsOnce = false;

    settings = loadSettings();
    bodyweightInput.value = settings.bodyweight;
    deletedIds = loadDeletedIds();
    customTemplates = loadCustomTemplates();
    hiddenDefaults = loadHiddenDefaults();
    initTemplates();
    initAppData();
  }

  // ===== Bodyweight =====
  bodyweightInput.addEventListener("input", () => {
    const v = parseFloat(bodyweightInput.value);
    if (Number.isFinite(v) && v > 0) {
      settings.bodyweight = v;
      saveSettings(settings);
    }
  });

  function rebuildLastByExercise() {
    lastByExercise = {};
    const sorted = [...entries].sort((a, b) => (a.date > b.date ? 1 : -1));
    for (const e of sorted) {
      const key = (e.exercise || "").toLowerCase();
      if (!key) continue;
      lastByExercise[key] = e;
    }
  }

  function getEffectiveSkillName() {
    let skill = skillInput.value;
    if (skill === "Custom") {
      const c = customSkillInput.value.trim();
      if (c) skill = c;
    }
    return skill;
  }

  function getCurrentSkillType() {
    return getSkillTypeFromSelectValue(skillInput.value);
  }

  function setSkillFromEntry(entry) {
    const opts = Array.from(skillInput.options).map(o => o.value);
    if (opts.includes(entry.skill)) {
      skillInput.value = entry.skill;
      customSkillInput.value = "";
    } else {
      skillInput.value = "Custom";
      customSkillInput.value = entry.skill || "";
    }
    updateSkillModeUI();
  }

  function updateSkillModeUI() {
    const val = skillInput.value;
    const type = getSkillTypeFromSelectValue(val);

    customSkillWrapper.style.display = val === "Custom" ? "block" : "none";

    if (type === "cardio") {
      rowStrength.style.display = "none";
      rowCardio.style.display = "flex";
      cardioModeSelect.value = "speed";
      cardioValueLabel.textContent = "Speed (mph)";
      cardioTimeContainer.style.display = "block";
    } else {
      rowStrength.style.display = "flex";
      rowCardio.style.display = "none";
    }

    weightContainer.style.display = type === "flexibility" ? "none" : "block";
  }

  function updateCardioModeUI() {
    const mode = cardioModeSelect.value;
    if (mode === "distance") {
      cardioValueLabel.textContent = "Distance (miles)";
      document.getElementById("cardioSecondLabel").textContent = "Time (minutes)";
      cardioTimeContainer.style.display = "block";
    } else if (mode === "speeddist") {
      cardioValueLabel.textContent = "Speed (mph)";
      document.getElementById("cardioSecondLabel").textContent = "Distance (miles)";
      cardioTimeContainer.style.display = "block";
    } else {
      cardioValueLabel.textContent = "Speed (mph)";
      document.getElementById("cardioSecondLabel").textContent = "Time (minutes)";
      cardioTimeContainer.style.display = "block";
    }
    updatePreview();
  }

  cardioModeSelect.addEventListener("change", updateCardioModeUI);

  function updatePreview() {
    const type = getCurrentSkillType();
    let sets = 0, reps = 0, weight = 0, speedOrDistance = 0, minutes = 0;
    const cardioMode = cardioModeSelect.value;

    if (type === "cardio") {
      speedOrDistance = parseFloat(cardioValueInput.value) || 0;
      minutes = parseFloat(cardioMinutesInput.value) || 0;
    } else {
      sets = parseFloat(setsInput.value) || 0;
      reps = parseFloat(repsInput.value) || 0;
      if (type === "strength") {
        weight = parseFloat(weightInput.value) || 0;
      }
    }

    const { volume, xp } = computeVolumeAndXp(
      type, sets, reps, weight, speedOrDistance, minutes,
      exerciseInput.value, settings.bodyweight, cardioMode
    );
    volumePreview.value = volume > 0 ? volume.toFixed(2) : "";
    xpPreview.value = xp > 0 ? xp.toString() : "";
  }

  skillInput.addEventListener("change", () => {
    updateSkillModeUI();
    updatePreview();
  });

  [setsInput, repsInput, weightInput, cardioValueInput, cardioMinutesInput, exerciseInput].forEach(el => {
    el.addEventListener("input", updatePreview);
  });

  function groupBySkill(entriesArr) {
    const map = new Map();
    for (const e of entriesArr) {
      const skill = e.skill || "Unknown";
      if (!map.has(skill)) {
        map.set(skill, { skill, totalXp: 0, totalVolume: 0, count: 0 });
      }
      const obj = map.get(skill);
      obj.totalXp += e.xp || 0;
      obj.totalVolume += e.volume || 0;
      obj.count += 1;
    }
    return Array.from(map.values());
  }

  function renderSkills() {
    const groups = groupBySkill(entries);
    skillsContainer.innerHTML = "";

    if (!groups.length) {
      skillsContainer.innerHTML = '<div class="muted">Log a workout to start gaining XP.</div>';
      prevSkillTotals = {};
      prevSkillLevels = {};
      hasRenderedSkillsOnce = true;
      return;
    }

    const newTotals = {};
    const newLevels = {};

    groups.sort((a, b) => b.totalXp - a.totalXp);

    for (const g of groups) {
      const level = getLevelFromXp(g.totalXp);
      newTotals[g.skill] = g.totalXp;
      newLevels[g.skill] = level;

      const tier = getTierInfo(level);

      const xpCurrent = totalXpForLevel(level);
      const xpNext = totalXpForLevel(Math.min(level + 1, MAX_LEVEL));
      const xpInto = g.totalXp - xpCurrent;
      const xpNeeded = Math.max(1, xpNext - xpCurrent);
      const pct = Math.min(100, Math.max(0, (xpInto / xpNeeded) * 100));

      const prevXp = prevSkillTotals[g.skill] || 0;
      const prevLevel = prevSkillLevels[g.skill] || 1;
      const prevCurrent = totalXpForLevel(prevLevel);
      const prevNext = totalXpForLevel(Math.min(prevLevel + 1, MAX_LEVEL));
      let prevPct = 0;
      if (prevNext > prevCurrent) {
        prevPct = Math.min(100, Math.max(0, ((prevXp - prevCurrent) / (prevNext - prevCurrent)) * 100));
      }

      const div = document.createElement("div");
      div.className = "skill-card";
      div.innerHTML = `
        <div class="skill-header">
          <div class="skill-name">
            ${g.skill}
            <span class="tier-pill">${tier.name}</span>
          </div>
          <div class="skill-level">Lvl ${level}</div>
        </div>
        <div class="skill-xp">
          ${g.totalXp.toLocaleString()} XP · ${xpInto.toLocaleString()} / ${xpNeeded.toLocaleString()} to next
        </div>
        <div class="progress-bar">
          <div class="progress-fill"></div>
        </div>
        <div class="muted" style="margin-top:4px;">
          ${g.count} entries · total volume ${g.totalVolume.toFixed(0)}
        </div>
      `;
      skillsContainer.appendChild(div);

      div.style.borderColor = tier.color + "80";
      const pill = div.querySelector(".tier-pill");
      pill.style.borderColor = tier.color;
      pill.style.color = tier.color;

      const fill = div.querySelector(".progress-fill");
      fill.style.background = `linear-gradient(to right, ${tier.color}, #0f172a)`;
      const levelEl = div.querySelector(".skill-level");

      if (!hasRenderedSkillsOnce) {
        fill.style.width = pct.toFixed(1) + "%";
      } else {
        fill.style.width = prevPct.toFixed(1) + "%";
        requestAnimationFrame(() => {
          fill.style.width = pct.toFixed(1) + "%";
        });
      }

      if (hasRenderedSkillsOnce && level > prevLevel) {
        levelEl.classList.add("skill-level-pop");
        setTimeout(() => levelEl.classList.remove("skill-level-pop"), 900);
      }
    }

    prevSkillTotals = newTotals;
    prevSkillLevels = newLevels;
    hasRenderedSkillsOnce = true;
  }

  // ===== Streak tracker =====
  function computeStreaks() {
    if (!entries.length) return { current: 0, longest: 0 };

    const uniqueDates = [...new Set(entries.map(e => e.date).filter(Boolean))].sort();
    if (!uniqueDates.length) return { current: 0, longest: 0 };

    // Convert to date objects for comparison
    function toDateObj(dateStr) {
      const [y, m, d] = dateStr.split("-").map(Number);
      return new Date(y, m - 1, d);
    }

    function daysBetween(d1, d2) {
      const ms = d2.getTime() - d1.getTime();
      return Math.round(ms / (1000 * 60 * 60 * 24));
    }

    let longest = 1;
    let currentStreak = 1;

    for (let i = 1; i < uniqueDates.length; i++) {
      const prev = toDateObj(uniqueDates[i - 1]);
      const curr = toDateObj(uniqueDates[i]);
      if (daysBetween(prev, curr) === 1) {
        currentStreak++;
      } else {
        currentStreak = 1;
      }
      if (currentStreak > longest) longest = currentStreak;
    }

    // Check if current streak is still active (last workout date is today or yesterday)
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const lastWorkout = toDateObj(uniqueDates[uniqueDates.length - 1]);
    const daysSinceLast = daysBetween(lastWorkout, today);

    let activeStreak = 0;
    if (daysSinceLast <= 1) {
      // Count backwards from the end
      activeStreak = 1;
      for (let i = uniqueDates.length - 2; i >= 0; i--) {
        const prev = toDateObj(uniqueDates[i]);
        const curr = toDateObj(uniqueDates[i + 1]);
        if (daysBetween(prev, curr) === 1) {
          activeStreak++;
        } else {
          break;
        }
      }
    }

    return { current: activeStreak, longest };
  }

  function renderStreaks() {
    const { current, longest } = computeStreaks();
    if (!entries.length) {
      streakWidget.style.display = "none";
      return;
    }
    streakWidget.style.display = "flex";
    currentStreakNum.textContent = current;
    longestStreakNum.textContent = longest;
  }

  function niceDateLabel(dateStr) {
    if (!dateStr) return "";
    const parts = dateStr.split("-");
    if (parts.length !== 3) return dateStr;
    const year = parseInt(parts[0], 10);
    const month = parseInt(parts[1], 10);
    const day = parseInt(parts[2], 10);
    if (!year || !month || !day) return dateStr;
    const d = new Date(year, month - 1, day);
    return d.toLocaleDateString(undefined, { weekday: "short", month: "short", day: "numeric" });
  }

  function updateHistoryToggle() {
    if (!entries.length) {
      historyWrapper.classList.remove("collapsed", "expanded");
      historyToggleBtn.style.display = "none";
      return;
    }
    historyToggleBtn.style.display = "inline-block";
    if (historyExpanded) {
      historyWrapper.classList.add("expanded");
      historyWrapper.classList.remove("collapsed");
      historyToggleBtn.textContent = "Collapse history";
    } else {
      historyWrapper.classList.add("collapsed");
      historyWrapper.classList.remove("expanded");
      historyToggleBtn.textContent = "Show all history";
    }
  }

  historyToggleBtn.addEventListener("click", () => {
    historyExpanded = !historyExpanded;
    updateHistoryToggle();
  });

  // ===== Delete entry =====
  function deleteEntry(entryId) {
    if (!confirm("Delete this entry?")) return;
    const idx = entries.findIndex(e => e.id === entryId);
    if (idx !== -1) {
      entries.splice(idx, 1);
      saveEntriesLocal(entries);
    }
    // Also track the ID so server entries stay hidden
    if (!deletedIds.includes(entryId)) {
      deletedIds.push(entryId);
      saveDeletedIds(deletedIds);
    }
    renderAll();
  }

  function renderHistory() {
    historyContainer.innerHTML = "";

    if (!entries.length) {
      emptyState.style.display = "block";
      updateHistoryToggle();
      return;
    }
    emptyState.style.display = "none";

    const byDate = new Map();
    for (const e of entries) {
      const key = e.date || "";
      if (!byDate.has(key)) byDate.set(key, []);
      byDate.get(key).push(e);
    }

    const dates = Array.from(byDate.keys()).sort((a, b) => (a < b ? 1 : -1));

    for (const date of dates) {
      const list = byDate.get(date);
      const dayDiv = document.createElement("div");
      dayDiv.className = "history-day";

      const totalXp = list.reduce((s, e) => s + (e.xp || 0), 0);

      dayDiv.innerHTML = `
        <div class="history-day-header">
          <div class="history-day-title">${niceDateLabel(date)}</div>
          <div class="history-day-sub">${totalXp.toLocaleString()} XP · ${list.length} entries</div>
        </div>
      `;

      list.sort((a, b) => (a.skill > b.skill ? 1 : -1));

      for (const e of list) {
        const row = document.createElement("div");
        row.className = "history-entry";
        row.innerHTML = `
          <div class="history-entry-main">
            <span class="tag">${e.skill}</span>
            &nbsp;${e.exercise}
            <span class="muted">(${formatEntryDetails(e)})</span>
          </div>
          <div class="history-entry-extra">
            <span>Vol ${e.volume.toFixed(2)} · ${e.xp.toLocaleString()} XP</span>
            <button type="button" class="delete-entry-btn" title="Delete entry">&times;</button>
          </div>
        `;
        const deleteBtn = row.querySelector(".delete-entry-btn");
        deleteBtn.addEventListener("click", () => deleteEntry(e.id));
        dayDiv.appendChild(row);
      }

      historyContainer.appendChild(dayDiv);
    }

    updateHistoryToggle();
  }

  function drawSkillXpBars(skillGroups) {
    const svg = statsSkillBars;
    if (!svg) return;
    svg.innerHTML = "";

    if (!skillGroups.length) return;

    const groups = skillGroups.slice().sort((a, b) => b.totalXp - a.totalXp);

    const width = 320;
    const height = 140;
    const paddingLeft = 40;
    const paddingRight = 10;
    const paddingTop = 10;
    const paddingBottom = 30;

    const plotWidth = width - paddingLeft - paddingRight;
    const plotHeight = height - paddingTop - paddingBottom;

    const maxXp = Math.max(...groups.map(g => g.totalXp));
    if (maxXp <= 0) return;

    const barSlotWidth = plotWidth / groups.length;
    const barWidth = Math.max(12, barSlotWidth * 0.6);

    const ns = "http://www.w3.org/2000/svg";

    const axis = document.createElementNS(ns, "line");
    axis.setAttribute("x1", paddingLeft);
    axis.setAttribute("y1", height - paddingBottom);
    axis.setAttribute("x2", width - paddingRight);
    axis.setAttribute("y2", height - paddingBottom);
    axis.setAttribute("stroke", "#1f2937");
    axis.setAttribute("stroke-width", "1");
    svg.appendChild(axis);

    groups.forEach((g, i) => {
      const centerX = paddingLeft + barSlotWidth * (i + 0.5);
      const ratio = g.totalXp / maxXp;
      const barHeight = plotHeight * ratio;
      const x = centerX - barWidth / 2;
      const y = height - paddingBottom - barHeight;

      const tier = getTierInfo(getLevelFromXp(g.totalXp));

      const rect = document.createElementNS(ns, "rect");
      rect.setAttribute("x", x);
      rect.setAttribute("y", y);
      rect.setAttribute("width", barWidth);
      rect.setAttribute("height", barHeight);
      rect.setAttribute("rx", "4");
      rect.setAttribute("fill", tier.color);
      svg.appendChild(rect);

      const xpLabel = document.createElementNS(ns, "text");
      xpLabel.setAttribute("x", centerX);
      xpLabel.setAttribute("y", y - 4);
      xpLabel.setAttribute("text-anchor", "middle");
      xpLabel.setAttribute("font-size", "8");
      xpLabel.setAttribute("fill", "#9ca3af");
      xpLabel.textContent = Math.round(g.totalXp).toLocaleString();
      svg.appendChild(xpLabel);

      const nameLabel = document.createElementNS(ns, "text");
      nameLabel.setAttribute("x", centerX);
      nameLabel.setAttribute("y", height - paddingBottom + 12);
      nameLabel.setAttribute("text-anchor", "middle");
      nameLabel.setAttribute("font-size", "8");
      nameLabel.setAttribute("fill", "#9ca3af");
      const shortName = g.skill.length > 8 ? g.skill.slice(0, 7) + "\u2026" : g.skill;
      nameLabel.textContent = shortName;
      svg.appendChild(nameLabel);
    });
  }

  function renderStatsPanel() {
    const skillGroups = groupBySkill(entries);
    drawSkillXpBars(skillGroups);

    const exercises = Array.from(
      new Set(entries.map(e => e.exercise).filter(Boolean))
    ).sort((a, b) => a.localeCompare(b));

    statsExerciseSelect.innerHTML = "";
    if (!exercises.length) {
      statsExerciseSelect.innerHTML = '<option value="">No data yet</option>';
      statsExerciseSummary.textContent = "Log some workouts to see progress.";
      statsVolumeChart.innerHTML = "";
      statsTableWrapper.innerHTML = "";
      return;
    }

    let selected = statsExerciseSelect.value;
    if (!selected || !exercises.includes(selected)) {
      selected = exercises[0];
    }

    exercises.forEach(name => {
      const opt = document.createElement("option");
      opt.value = name;
      opt.textContent = name;
      if (name === selected) opt.selected = true;
      statsExerciseSelect.appendChild(opt);
    });

    renderStatsForExercise(selected);
  }

  statsExerciseSelect.addEventListener("change", () => {
    const name = statsExerciseSelect.value;
    if (name) renderStatsForExercise(name);
  });

  function renderStatsForExercise(name) {
    const filtered = entries.filter(e => e.exercise === name);
    if (!filtered.length) {
      statsExerciseSummary.textContent = "No logs yet.";
      statsVolumeChart.innerHTML = "";
      statsTableWrapper.innerHTML = "";
      return;
    }

    filtered.sort((a, b) => (a.date > b.date ? 1 : -1));

    const firstDate = filtered[0].date;
    const lastDate = filtered[filtered.length - 1].date;
    const lastEntry = filtered[filtered.length - 1];

    statsExerciseSummary.textContent =
      `From ${niceDateLabel(firstDate)} to ${niceDateLabel(lastDate)} · ` +
      `Last volume ${lastEntry.volume.toFixed(2)} (${formatEntryDetails(lastEntry)})`;

    const byDate = new Map();
    for (const e of filtered) {
      const key = e.date || "";
      byDate.set(key, (byDate.get(key) || 0) + e.volume);
    }
    const orderedDates = Array.from(byDate.keys()).sort();
    const series = orderedDates.map(d => ({ date: d, volume: byDate.get(d) }));

    drawVolumeChart(series);
    renderStatsTable(filtered);
  }

  function drawVolumeChart(series) {
    const svg = statsVolumeChart;
    svg.innerHTML = "";
    if (!series.length) return;

    const width = 320;
    const height = 140;
    const paddingLeft = 24;
    const paddingRight = 4;
    const paddingTop = 10;
    const paddingBottom = 20;

    const plotWidth = width - paddingLeft - paddingRight;
    const plotHeight = height - paddingTop - paddingBottom;

    const maxVol = Math.max(...series.map(p => p.volume));

    const points = series.map((p, idx) => {
      const x = paddingLeft +
        (series.length === 1 ? plotWidth / 2 : (plotWidth * idx) / (series.length - 1));
      const ratio = (p.volume - 0) / (maxVol || 1);
      const y = paddingTop + (plotHeight * (1 - ratio));
      return { x, y, date: p.date, volume: p.volume };
    });

    const ns = "http://www.w3.org/2000/svg";

    const axis = document.createElementNS(ns, "line");
    axis.setAttribute("x1", paddingLeft);
    axis.setAttribute("y1", height - paddingBottom);
    axis.setAttribute("x2", width - paddingRight);
    axis.setAttribute("y2", height - paddingBottom);
    axis.setAttribute("stroke", "#1f2937");
    axis.setAttribute("stroke-width", "1");
    svg.appendChild(axis);

    let pathD = "";
    points.forEach((pt, i) => {
      pathD += (i === 0 ? "M" : "L") + pt.x + " " + pt.y + " ";
    });
    const path = document.createElementNS(ns, "path");
    path.setAttribute("d", pathD);
    path.setAttribute("fill", "none");
    path.setAttribute("stroke", "#22c55e");
    path.setAttribute("stroke-width", "2");
    svg.appendChild(path);

    points.forEach(pt => {
      const c = document.createElementNS(ns, "circle");
      c.setAttribute("cx", pt.x);
      c.setAttribute("cy", pt.y);
      c.setAttribute("r", "3");
      c.setAttribute("fill", "#38bdf8");
      svg.appendChild(c);
    });
  }

  function renderStatsTable(filtered) {
    const container = statsTableWrapper;
    container.innerHTML = "";
    if (!filtered.length) {
      container.innerHTML = '<div class="muted">No logs yet.</div>';
      return;
    }

    const tbl = document.createElement("table");
    const thead = document.createElement("thead");
    thead.innerHTML =
      "<tr><th>Date</th><th>Skill</th><th>Details</th><th>Volume</th><th>XP</th></tr>";
    const tbody = document.createElement("tbody");

    filtered.forEach(e => {
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${niceDateLabel(e.date)}</td>
        <td>${e.skill}</td>
        <td>${formatEntryDetails(e)}</td>
        <td>${e.volume.toFixed(2)}</td>
        <td>${e.xp.toLocaleString()}</td>
      `;
      tbody.appendChild(tr);
    });

    tbl.appendChild(thead);
    tbl.appendChild(tbody);
    container.appendChild(tbl);
  }

  function renderAll() {
    rebuildLastByExercise();
    renderSkills();
    renderStreaks();
    renderHistory();
    renderTemplateExercises(templateSelect.value || "");
    renderStatsPanel();
  }

  // ===== Template exercise fill =====
  function fillFromTemplateExercise(tpl, ex) {
    workoutInput.value = tpl.name;
    exerciseInput.value = ex.name || "";

    setsInput.value = "";
    repsInput.value = "";
    weightInput.value = "";
    cardioValueInput.value = "";
    cardioMinutesInput.value = "";

    const key = (ex.name || "").toLowerCase();
    const last = lastByExercise[key];

    if (last) {
      setSkillFromEntry(last);
      setsInput.value = last.sets || "";
      repsInput.value = last.reps || "";
      weightInput.value = last.weight || "";
      cardioValueInput.value = last.speed || "";
      cardioMinutesInput.value = last.minutes || "";
      if (last.skillType === "cardio") {
        const mode = last.cardioMode || (last.minutes > 0 && last.speed > 0 ? "speed" : "distance");
        cardioModeSelect.value = mode;
        updateCardioModeUI();
      }
    } else {
      // Use per-exercise skill, then auto-detect, then template default
      const exSkill = ex.skill || getSkillForExercise(ex.name, tpl.defaultSkill);
      skillInput.value = exSkill;
      updateSkillModeUI();
      const pres = ex.prescription || "";
      if (pres.startsWith("cardio:")) {
        skillInput.value = "Cardio";
        updateSkillModeUI();
        const c = parseCardioPrescription(pres);
        if (c) {
          cardioModeSelect.value = "speed";
          updateCardioModeUI();
          cardioValueInput.value = c.speed.toString();
          cardioMinutesInput.value = c.minutes.toString();
        }
      } else if (pres.startsWith("flex:")) {
        skillInput.value = "Flexibility";
        updateSkillModeUI();
        const f = parseFlexPrescription(pres);
        if (f) {
          setsInput.value = f.sets.toString();
          repsInput.value = f.reps.toString();
        }
      } else {
        const s = parseStrengthPrescription(pres);
        if (s) {
          setsInput.value = s.sets.toString();
          repsInput.value = s.reps.toString();
          if (s.weight != null) {
            weightInput.value = s.weight.toString();
          }
        }
      }
    }

    updatePreview();
    exerciseInput.focus();
  }

  // ===== Quick log =====
  function quickLogExercise(tpl, ex) {
    const key = (ex.name || "").toLowerCase();
    const last = lastByExercise[key];
    if (!last) return;

    const today = dateInput.value || new Date().toISOString().slice(0, 10);

    const entry = {
      id: Date.now(),
      date: today,
      workout: tpl.name,
      skill: last.skill,
      skillType: last.skillType,
      exercise: last.exercise,
      sets: last.sets,
      reps: last.reps,
      weight: last.weight,
      speed: last.speed,
      minutes: last.minutes,
      volume: last.volume,
      xp: last.xp,
      cardioMode: last.cardioMode,
      user: currentUser
    };

    // Recalc with current bodyweight
    const { volume, xp } = computeVolumeAndXp(
      entry.skillType, entry.sets, entry.reps, entry.weight,
      entry.speed, entry.minutes, entry.exercise,
      settings.bodyweight, entry.cardioMode
    );
    entry.volume = volume;
    entry.xp = xp;

    entries.push(entry);
    saveEntriesLocal(entries);
    saveEntryToServer(entry);
    renderAll();
    showToast(entry);
  }

  function renderTemplateExercises(templateValue) {
    if (templateValue === "" || templateValue == null) {
      templateExercisesDiv.innerHTML = '<div class="muted">Select a routine above.</div>';
      return;
    }

    if (templateValue === "__create__") {
      showTemplateBuilderModal();
      // Reset selection
      templateSelect.value = "";
      templateExercisesDiv.innerHTML = '<div class="muted">Select a routine above.</div>';
      return;
    }

    if (templateValue === "__restore_defaults__") {
      if (confirm("Restore all hidden built-in routines?")) {
        hiddenDefaults = [];
        saveHiddenDefaults(hiddenDefaults);
        initTemplates();
      }
      templateSelect.value = "";
      templateExercisesDiv.innerHTML = '<div class="muted">Select a routine above.</div>';
      return;
    }

    let tpl = null;
    let isBuiltin = false;
    let builtinIdx = -1;
    if (templateValue.startsWith("builtin_")) {
      builtinIdx = parseInt(templateValue.slice(8), 10);
      tpl = defaultTemplates[builtinIdx];
      isBuiltin = true;
    } else if (templateValue.startsWith("custom_tpl_")) {
      const id = templateValue.slice(11);
      tpl = customTemplates.find(t => String(t.id) === id);
    }

    if (!tpl || !tpl.exercises || !tpl.exercises.length) {
      templateExercisesDiv.innerHTML = '<div class="muted">No exercises defined for this routine yet.</div>';
      return;
    }
    templateExercisesDiv.innerHTML = "";

    tpl.exercises.forEach(ex => {
      const card = document.createElement("div");
      card.className = "template-card";

      const key = (ex.name || "").toLowerCase();
      const last = lastByExercise[key];
      const lastText = last
        ? `Last: ${formatEntryDetails(last)} (${last.date})`
        : "No log yet";
      const exSkill = ex.skill || getSkillForExercise(ex.name, tpl.defaultSkill);

      card.innerHTML = `
        <div><strong>${ex.name}</strong> <span class="muted" style="font-size:0.75rem;">[${exSkill}]</span></div>
        <div class="template-prescription">Template: ${ex.prescription || ""}</div>
        <div class="template-last">${lastText}</div>
        <div>
          <button type="button" class="template-use-btn">Use in form</button>
          ${last ? '<button type="button" class="template-quicklog-btn">Quick log</button>' : ''}
        </div>
      `;
      const useBtn = card.querySelector(".template-use-btn");
      useBtn.addEventListener("click", () => fillFromTemplateExercise(tpl, ex));

      const quickBtn = card.querySelector(".template-quicklog-btn");
      if (quickBtn) {
        quickBtn.addEventListener("click", () => quickLogExercise(tpl, ex));
      }

      templateExercisesDiv.appendChild(card);
    });

    // Add remove/hide button for built-in routines
    if (isBuiltin) {
      const removeBtn = document.createElement("button");
      removeBtn.type = "button";
      removeBtn.className = "danger";
      removeBtn.style.cssText = "margin-top:8px; font-size:0.8rem; padding:6px 12px;";
      removeBtn.textContent = "Remove this routine";
      removeBtn.addEventListener("click", () => {
        if (!confirm(`Remove "${tpl.name}" from your routine list? You can restore it later.`)) return;
        hiddenDefaults.push(builtinIdx);
        saveHiddenDefaults(hiddenDefaults);
        templateSelect.value = "";
        initTemplates();
      });
      templateExercisesDiv.appendChild(removeBtn);
    }
  }

  // ===== Template dropdown (with optgroups) =====
  function initTemplates() {
    templateSelect.innerHTML = '<option value="">Pick a routine...</option>';

    // Built-in routines (skip hidden ones)
    const visibleDefaults = defaultTemplates.filter((_, idx) => !hiddenDefaults.includes(idx));
    if (visibleDefaults.length) {
      const builtinGroup = document.createElement("optgroup");
      builtinGroup.label = "Built-in routines";
      defaultTemplates.forEach((tpl, idx) => {
        if (hiddenDefaults.includes(idx)) return;
        const opt = document.createElement("option");
        opt.value = "builtin_" + idx;
        opt.textContent = tpl.name;
        builtinGroup.appendChild(opt);
      });
      templateSelect.appendChild(builtinGroup);
    }

    // Custom routines
    if (customTemplates.length) {
      const customGroup = document.createElement("optgroup");
      customGroup.label = "My routines";
      customTemplates.forEach(tpl => {
        const opt = document.createElement("option");
        opt.value = "custom_tpl_" + tpl.id;
        opt.textContent = tpl.name;
        customGroup.appendChild(opt);
      });
      templateSelect.appendChild(customGroup);
    }

    // Restore hidden defaults option (if any are hidden)
    if (hiddenDefaults.length > 0) {
      const restoreOpt = document.createElement("option");
      restoreOpt.value = "__restore_defaults__";
      restoreOpt.textContent = "↩ Restore hidden routines (" + hiddenDefaults.length + ")";
      templateSelect.appendChild(restoreOpt);
    }

    // Create new option
    const createOpt = document.createElement("option");
    createOpt.value = "__create__";
    createOpt.textContent = "+ Create new routine...";
    templateSelect.appendChild(createOpt);

    templateSelect.removeEventListener("change", handleTemplateChange);
    templateSelect.addEventListener("change", handleTemplateChange);
    renderTemplateExercises("");
  }

  function handleTemplateChange() {
    renderTemplateExercises(templateSelect.value);
  }

  // ===== Template builder modal =====
  function showTemplateBuilderModal(editTemplate) {
    const isEdit = !!editTemplate;
    const overlay = document.createElement("div");
    overlay.className = "modal-overlay";

    let exerciseRows = isEdit
      ? editTemplate.exercises.map(e => ({ name: e.name, prescription: e.prescription, skill: e.skill || "" }))
      : [{ name: "", prescription: "", skill: "" }];

    const skillOptions = ["", "Push", "Pull", "Legs", "Core", "Cardio", "Flexibility"];

    function renderExerciseList() {
      const container = overlay.querySelector("#tplBuilderExercises");
      if (!container) return;
      container.innerHTML = "";
      exerciseRows.forEach((ex, i) => {
        const row = document.createElement("div");
        row.className = "tpl-builder-exercise";
        const skillSelect = skillOptions.map(s =>
          `<option value="${s}" ${ex.skill === s ? 'selected' : ''}>${s || "Auto"}</option>`
        ).join("");
        row.innerHTML = `
          <div style="flex:2;">
            <input type="text" placeholder="Exercise name" value="${ex.name.replace(/"/g, '&quot;')}" data-idx="${i}" data-field="name" />
          </div>
          <div style="flex:1;">
            <select data-idx="${i}" data-field="skill" style="width:100%;padding:6px 4px;font-size:0.8rem;">${skillSelect}</select>
          </div>
          <div style="flex:2;">
            <input type="text" placeholder="e.g. 3x10x135 or cardio:6.5x15" value="${ex.prescription.replace(/"/g, '&quot;')}" data-idx="${i}" data-field="prescription" />
          </div>
          <button type="button" class="remove-ex-btn" data-idx="${i}">&times;</button>
        `;
        container.appendChild(row);
      });

      // Wire up inputs and selects
      container.querySelectorAll("input, select").forEach(el => {
        const evtType = el.tagName === "SELECT" ? "change" : "input";
        el.addEventListener(evtType, () => {
          const idx = parseInt(el.dataset.idx, 10);
          exerciseRows[idx][el.dataset.field] = el.value;
          // Auto-detect skill when exercise name changes and skill is set to Auto
          if (el.dataset.field === "name" && !exerciseRows[idx].skill) {
            const detected = getSkillForExercise(el.value, "");
            const skillSel = container.querySelector(`select[data-idx="${idx}"]`);
            if (skillSel && detected) {
              // Show detected skill as placeholder but keep value as auto
              skillSel.title = "Auto-detected: " + detected;
            }
          }
        });
      });
      container.querySelectorAll(".remove-ex-btn").forEach(btn => {
        btn.addEventListener("click", () => {
          const idx = parseInt(btn.dataset.idx, 10);
          if (exerciseRows.length > 1) {
            exerciseRows.splice(idx, 1);
            renderExerciseList();
          }
        });
      });
    }

    overlay.innerHTML = `
      <div class="modal-content">
        <h2>${isEdit ? "Edit routine" : "Create new routine"}</h2>
        <label>Routine name</label>
        <input type="text" id="tplBuilderName" value="${isEdit ? editTemplate.name.replace(/"/g, '&quot;') : ''}" placeholder="e.g. Full Body A" />
        <label>Default skill</label>
        <select id="tplBuilderSkill">
          <option value="Legs">Legs</option>
          <option value="Push">Push</option>
          <option value="Pull">Pull</option>
          <option value="Core">Core</option>
          <option value="Cardio">Cardio</option>
          <option value="Flexibility">Flexibility</option>
        </select>
        <label style="margin-top:8px;">Exercises</label>
        <div class="muted" style="font-size:0.7rem; margin-bottom:4px;">
          Skill: set per exercise or leave as "Auto" to detect automatically.<br/>
          Prescription formats: <code>3x10x135</code> (strength), <code>3x10xBW</code> (bodyweight),
          <code>cardio:6.5x15</code> (speed x min), <code>flex:3x10</code> (sets x reps)
        </div>
        <div id="tplBuilderExercises"></div>
        <button type="button" class="secondary" id="tplAddExBtn" style="margin-top:6px; font-size:0.8rem; padding:6px 10px;">+ Add exercise</button>
        <div style="margin-top:12px; display:flex; gap:8px; flex-wrap:wrap;">
          <button type="button" id="tplSaveBtn">${isEdit ? "Save changes" : "Create routine"}</button>
          ${isEdit ? '<button type="button" class="danger" id="tplDeleteBtn">Delete routine</button>' : ''}
          <button type="button" class="secondary" id="tplCancelBtn">Cancel</button>
        </div>
      </div>
    `;
    document.body.appendChild(overlay);

    if (isEdit) {
      overlay.querySelector("#tplBuilderSkill").value = editTemplate.defaultSkill || "Push";
    }

    renderExerciseList();

    overlay.querySelector("#tplAddExBtn").addEventListener("click", () => {
      exerciseRows.push({ name: "", prescription: "", skill: "" });
      renderExerciseList();
    });

    overlay.querySelector("#tplSaveBtn").addEventListener("click", () => {
      const name = overlay.querySelector("#tplBuilderName").value.trim();
      const defaultSkill = overlay.querySelector("#tplBuilderSkill").value;
      const exercises = exerciseRows
        .filter(e => e.name.trim())
        .map(e => ({
          name: e.name.trim(),
          prescription: e.prescription.trim(),
          skill: e.skill || getSkillForExercise(e.name.trim(), defaultSkill)
        }));

      if (!name) {
        alert("Please enter a routine name.");
        return;
      }
      if (!exercises.length) {
        alert("Add at least one exercise.");
        return;
      }

      if (isEdit) {
        const tpl = customTemplates.find(t => t.id === editTemplate.id);
        if (tpl) {
          tpl.name = name;
          tpl.defaultSkill = defaultSkill;
          tpl.exercises = exercises;
        }
      } else {
        customTemplates.push({
          id: Date.now(),
          name,
          defaultSkill,
          exercises
        });
      }

      saveCustomTemplates(customTemplates);
      overlay.remove();
      initTemplates();
    });

    const deleteBtn = overlay.querySelector("#tplDeleteBtn");
    if (deleteBtn) {
      deleteBtn.addEventListener("click", () => {
        if (!confirm("Delete this routine?")) return;
        customTemplates = customTemplates.filter(t => t.id !== editTemplate.id);
        saveCustomTemplates(customTemplates);
        overlay.remove();
        initTemplates();
      });
    }

    overlay.querySelector("#tplCancelBtn").addEventListener("click", () => {
      overlay.remove();
    });
  }

  // ===== Toast with undo =====
  function showToast(entry) {
    // Remove existing toast
    const existing = document.querySelector(".toast-bar");
    if (existing) existing.remove();
    if (toastTimeout) clearTimeout(toastTimeout);

    const toast = document.createElement("div");
    toast.className = "toast-bar";
    toast.innerHTML = `
      <span>Logged <strong>${entry.exercise}</strong> — ${formatEntryDetails(entry)} — +${entry.xp} XP</span>
      <button type="button" class="toast-undo-btn">Undo</button>
    `;
    document.body.appendChild(toast);

    const undoBtn = toast.querySelector(".toast-undo-btn");
    undoBtn.addEventListener("click", () => {
      // Remove the entry
      const idx = entries.findIndex(e => e.id === entry.id);
      if (idx !== -1) {
        entries.splice(idx, 1);
        saveEntriesLocal(entries);
        // Track as deleted so server copy is hidden
        if (!deletedIds.includes(entry.id)) {
          deletedIds.push(entry.id);
          saveDeletedIds(deletedIds);
        }
        renderAll();
      }
      toast.remove();
      if (toastTimeout) clearTimeout(toastTimeout);
    });

    toastTimeout = setTimeout(() => {
      toast.remove();
    }, 5000);
  }

  // ===== Tabs =====
  tabOverviewBtn.addEventListener("click", () => {
    tabOverviewBtn.classList.add("active");
    tabStatsBtn.classList.remove("active");
    overviewPane.style.display = "block";
    statsPane.style.display = "none";
  });

  tabStatsBtn.addEventListener("click", () => {
    tabStatsBtn.classList.add("active");
    tabOverviewBtn.classList.remove("active");
    overviewPane.style.display = "none";
    statsPane.style.display = "block";
    renderStatsPanel();
  });

  // ===== Log form submit =====
  logForm.addEventListener("submit", async (e) => {
    e.preventDefault();
    const date = dateInput.value;
    const workout = workoutInput.value.trim();
    const skillName = getEffectiveSkillName();
    const skillType = getCurrentSkillType();
    const exercise = exerciseInput.value.trim();

    let sets = 0, reps = 0, weight = 0, speedOrDistance = 0, minutes = 0;
    const cardioMode = cardioModeSelect.value;

    if (!date || !exercise) {
      alert("Please fill date and exercise.");
      return;
    }

    if (skillType === "cardio") {
      speedOrDistance = parseFloat(cardioValueInput.value) || 0;
      minutes = parseFloat(cardioMinutesInput.value) || 0;

      if (cardioMode === "speed") {
        if (speedOrDistance <= 0 || minutes <= 0) {
          alert("Fill speed (mph) and minutes for cardio.");
          return;
        }
      } else if (cardioMode === "speeddist") {
        if (speedOrDistance <= 0 || minutes <= 0) {
          alert("Fill speed (mph) and distance (miles) for cardio.");
          return;
        }
      } else {
        if (speedOrDistance <= 0 || minutes <= 0) {
          alert("Fill distance (miles) and minutes for cardio.");
          return;
        }
      }
    } else {
      sets = parseInt(setsInput.value, 10) || 0;
      reps = parseInt(repsInput.value, 10) || 0;
      if (sets <= 0 || reps <= 0) {
        alert("Fill sets and reps.");
        return;
      }
      if (skillType === "strength") {
        weight = parseFloat(weightInput.value) || 0;
        if (weight < 0) {
          alert("Weight cannot be negative.");
          return;
        }
      }
    }

    const { volume, xp } = computeVolumeAndXp(
      skillType, sets, reps, weight, speedOrDistance, minutes,
      exercise, settings.bodyweight, cardioMode
    );

    const entry = {
      id: Date.now(),
      date,
      workout,
      skill: skillName,
      skillType,
      exercise,
      sets,
      reps,
      weight,
      speed: speedOrDistance,
      minutes,
      volume,
      xp,
      cardioMode: skillType === "cardio" ? cardioMode : null,
      user: currentUser
    };

    entries.push(entry);
    saveEntriesLocal(entries);
    saveEntryToServer(entry);
    renderAll();
    showToast(entry);

    exerciseInput.value = "";
    setsInput.value = "";
    repsInput.value = "";
    weightInput.value = "";
    cardioValueInput.value = "";
    cardioMinutesInput.value = "";
    volumePreview.value = "";
    xpPreview.value = "";
  });

  // ===== Clear data (scoped to current user) =====
  clearAllBtn.addEventListener("click", async () => {
    if (!confirm(`Clear all local data for "${currentUser}"?`)) return;
    entries.splice(0, entries.length);
    saveEntriesLocal(entries);
    deletedIds = [];
    saveDeletedIds(deletedIds);
    renderAll();
  });

  // ===== Export / Import =====
  exportBtn.addEventListener("click", () => {
    const data = {
      user: currentUser,
      entries: entries,
      settings: settings,
      customTemplates: customTemplates,
      deletedIds: deletedIds,
      exportedAt: new Date().toISOString()
    };
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `workout-grind-${currentUser}-${new Date().toISOString().slice(0, 10)}.json`;
    a.click();
    URL.revokeObjectURL(url);
  });

  importBtn.addEventListener("click", () => {
    importFileInput.click();
  });

  importFileInput.addEventListener("change", (e) => {
    const file = e.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (evt) => {
      try {
        const data = JSON.parse(evt.target.result);
        if (!data || !Array.isArray(data.entries)) {
          alert("Invalid backup file.");
          return;
        }
        if (!confirm(`Import ${data.entries.length} entries for "${currentUser}"? This will replace your current data.`)) {
          return;
        }

        entries.splice(0, entries.length, ...data.entries);
        saveEntriesLocal(entries);

        if (data.settings) {
          settings = data.settings;
          saveSettings(settings);
          bodyweightInput.value = settings.bodyweight;
        }

        if (Array.isArray(data.customTemplates)) {
          customTemplates = data.customTemplates;
          saveCustomTemplates(customTemplates);
          initTemplates();
        }

        if (Array.isArray(data.deletedIds)) {
          deletedIds = data.deletedIds;
          saveDeletedIds(deletedIds);
        }

        recalcEntriesUsingCurrentFormulas(entries);
        renderAll();
        alert("Import complete!");
      } catch (err) {
        alert("Failed to read file: " + err.message);
      }
    };
    reader.readAsText(file);
    importFileInput.value = "";
  });

  // ===== Init =====
  async function initAppData() {
    updateSkillModeUI();
    updateCardioModeUI();

    const local = loadEntriesLocal();
    deletedIds = loadDeletedIds();
    let loaded = [];
    const server = await fetchEntriesFromServer();

    if (server === null) {
      if (SERVER_URL) {
        setCloudStatus("Cloud sync: local only (could not reach server)");
      }
      loaded = local;
    } else if (server.length === 0 && local.length > 0) {
      loaded = local;
      setCloudStatus("Cloud sync: connected (using local history)");
    } else {
      loaded = server;
      if (!server.length) {
        setCloudStatus("Cloud sync: connected (no rows yet)");
      }
    }

    // Filter out deleted entries
    if (deletedIds.length) {
      const deletedSet = new Set(deletedIds);
      loaded = loaded.filter(e => !deletedSet.has(e.id));
    }

    entries.splice(0, entries.length, ...loaded);
    recalcEntriesUsingCurrentFormulas(entries);
    renderAll();
  }

  function initApp() {
    // Check if we have a current user
    const savedUser = localStorage.getItem(USER_CURRENT_KEY);
    const knownUsers = getKnownUsers();

    if (savedUser && knownUsers.includes(savedUser)) {
      // Existing user
      currentUser = savedUser;
      populateUserSelect();
      settings = loadSettings();
      bodyweightInput.value = settings.bodyweight;
      customTemplates = loadCustomTemplates();
      hiddenDefaults = loadHiddenDefaults();
      initTemplates();
      initAppData();
    } else if (knownUsers.length > 0) {
      // Known users exist but no current user set
      currentUser = knownUsers[0];
      localStorage.setItem(USER_CURRENT_KEY, currentUser);
      populateUserSelect();
      settings = loadSettings();
      bodyweightInput.value = settings.bodyweight;
      customTemplates = loadCustomTemplates();
      hiddenDefaults = loadHiddenDefaults();
      initTemplates();
      initAppData();
    } else {
      // First-time visitor — show modal
      // Check for legacy data
      showNewUserModal(true);
    }
  }

  initApp();
</script>
</body>
</html>
