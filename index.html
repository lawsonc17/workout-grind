<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Workout Grind Tracker</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    * {
      box-sizing: border-box;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    body {
      margin: 0;
      padding: 16px;
      background: #050816;
      color: #f3f4f6;
    }
    h1, h2, h3 {
      margin-top: 0;
    }
    .app-shell {
      max-width: 1100px;
      margin: 0 auto;
    }
    .header {
      margin-bottom: 16px;
      display: flex;
      justify-content: space-between;
      gap: 12px;
      align-items: flex-end;
      flex-wrap: wrap;
    }
    .header-main {
      flex: 1;
      min-width: 220px;
    }
    .header-title {
      font-size: 1.8rem;
      font-weight: 700;
    }
    .header-subtitle {
      font-size: 0.9rem;
      color: #9ca3af;
    }
    .header-settings {
      min-width: 220px;
    }

    .grid {
      display: grid;
      grid-template-columns: minmax(0, 1.2fr) minmax(0, 1.8fr);
      gap: 16px;
    }
    @media (max-width: 800px) {
      .grid {
        grid-template-columns: minmax(0, 1fr);
      }
    }

    .card {
      background: radial-gradient(circle at top left, #1f2937, #020617);
      border-radius: 18px;
      padding: 16px;
      border: 1px solid #111827;
      box-shadow: 0 18px 40px rgba(0,0,0,0.65);
    }
    .card h2 {
      font-size: 1.05rem;
      margin-bottom: 8px;
    }

    label {
      font-size: 0.8rem;
      color: #9ca3af;
      display: block;
      margin-bottom: 4px;
    }
    input, select {
      width: 100%;
      padding: 8px;
      border-radius: 10px;
      border: 1px solid #1f2937;
      background: #020617;
      color: #f9fafb;
      font-size: 0.85rem;
      outline: none;
    }
    input:focus, select:focus {
      border-color: #38bdf8;
      box-shadow: 0 0 0 1px #0ea5e9;
    }

    .row {
      display: flex;
      gap: 8px;
      margin-bottom: 10px;
    }
    .row > div {
      flex: 1;
    }

    button {
      padding: 10px 14px;
      border-radius: 999px;
      border: none;
      background: linear-gradient(to right, #0ea5e9, #22c55e);
      color: #0b1120;
      font-weight: 600;
      cursor: pointer;
      font-size: 0.9rem;
    }
    button:hover {
      opacity: 0.9;
    }
    button.secondary {
      background: #111827;
      color: #e5e7eb;
      border: 1px solid #1f2937;
    }

    .inline-buttons {
      display: flex;
      justify-content: space-between;
      gap: 8px;
      margin-top: 8px;
      flex-wrap: wrap;
    }

    .skills-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 10px;
    }
    .skill-card {
      background: #020617;
      border-radius: 14px;
      padding: 10px;
      border: 1px solid #0f172a;
    }
    .skill-header {
      display: flex;
      justify-content: space-between;
      margin-bottom: 4px;
      gap: 4px;
    }
    .skill-name {
      font-size: 0.9rem;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 4px;
      flex-wrap: wrap;
    }
    .skill-level {
      font-size: 0.9rem;
      color: #a5b4fc;
    }
    .tier-pill {
      padding: 2px 6px;
      border-radius: 999px;
      font-size: 0.7rem;
      border: 1px solid rgba(148,163,184,0.6);
    }
    .skill-xp {
      font-size: 0.75rem;
      color: #9ca3af;
      margin-bottom: 4px;
    }
    .progress-bar {
      background: #020617;
      border-radius: 999px;
      border: 1px solid #111827;
      height: 8px;
      overflow: hidden;
    }
    .progress-fill {
      background: linear-gradient(to right, #22c55e, #84cc16);
      height: 100%;
      width: 0%;
      transition: width 1.6s cubic-bezier(0.16, 1, 0.3, 1);
    }

    .skill-level-pop {
      animation: levelUpPop 0.9s ease-out;
    }
    @keyframes levelUpPop {
      0% {
        transform: scale(1);
        filter: drop-shadow(0 0 0 rgba(248,250,252,0));
      }
      40% {
        transform: scale(1.35);
        filter: drop-shadow(0 0 14px rgba(248,250,252,0.9));
      }
      100% {
        transform: scale(1);
        filter: drop-shadow(0 0 0 rgba(248,250,252,0));
      }
    }

    .muted {
      color: #6b7280;
      font-size: 0.78rem;
    }
    .tag {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 999px;
      font-size: 0.7rem;
      border: 1px solid #1f2937;
      background: #020617;
      color: #e5e7eb;
    }

    /* Templates UI */
    .template-header {
      margin-bottom: 4px;
    }
    .template-list-title {
      font-size: 0.9rem;
      font-weight: 600;
      margin-bottom: 2px;
    }
    .template-hint {
      font-size: 0.7rem;
    }
    .template-exercises {
      margin-top: 8px;
      max-height: 200px;
      overflow-y: auto;
    }
    .template-card {
      border-radius: 10px;
      border: 1px solid #111827;
      padding: 6px 8px;
      margin-bottom: 6px;
      background: #020617;
    }
    .template-prescription {
      font-size: 0.75rem;
      color: #9ca3af;
      margin: 2px 0 2px;
    }
    .template-last {
      font-size: 0.7rem;
      color: #a5b4fc;
      margin-bottom: 4px;
    }
    .template-use-btn {
      padding: 4px 8px;
      border-radius: 999px;
      border: none;
      background: #0ea5e9;
      color: #0b1120;
      font-size: 0.7rem;
      cursor: pointer;
    }

    hr {
      border: none;
      border-top: 1px solid #111827;
      margin: 10px 0;
    }

    /* History / day grouping */
    .history-day {
      border-radius: 14px;
      border: 1px solid #111827;
      padding: 8px 10px;
      margin-bottom: 8px;
      background: #020617;
    }
    .history-day-header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      margin-bottom: 4px;
    }
    .history-day-title {
      font-size: 0.9rem;
      font-weight: 600;
    }
    .history-day-sub {
      font-size: 0.7rem;
      color: #6b7280;
    }
    .history-entry {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      font-size: 0.78rem;
      padding: 2px 0;
      border-top: 1px solid #111827;
    }
    .history-entry:first-of-type {
      border-top: none;
    }
    .history-entry-main {
      flex: 2;
      min-width: 140px;
    }
    .history-entry-extra {
      flex: 1;
      min-width: 110px;
      text-align: right;
      color: #9ca3af;
    }

    /* History collapse */
    #historyWrapper.collapsed {
      max-height: 240px;
      overflow: hidden;
    }
    #historyWrapper.expanded {
      max-height: none;
    }
    #historyToggleBtn {
      margin-top: 4px;
      font-size: 0.75rem;
      padding: 4px 8px;
    }

    /* Tabs */
    .tabs {
      display: flex;
      gap: 6px;
      margin-bottom: 8px;
      flex-wrap: wrap;
    }
    .tab-btn {
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid #1f2937;
      background: #020617;
      color: #9ca3af;
      font-size: 0.8rem;
      cursor: pointer;
    }
    .tab-btn.active {
      background: #0ea5e9;
      color: #0b1120;
      border-color: #38bdf8;
    }

    /* Stats */
    #statsVolumeChart {
      background: #020617;
      border-radius: 10px;
      border: 1px solid #111827;
    }
    #statsSkillBars {
      background: #020617;
      border-radius: 10px;
      border: 1px solid #111827;
    }
    #statsTableWrapper table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.78rem;
    }
    #statsTableWrapper th,
    #statsTableWrapper td {
      padding: 4px;
      text-align: left;
      border-bottom: 1px solid #111827;
      white-space: nowrap;
    }
    #statsTableWrapper th {
      font-size: 0.75rem;
    }
  </style>
</head>
<body>
  <div class="app-shell">
    <div class="header">
      <div class="header-main">
        <div class="header-title">Workout Grind Tracker</div>
        <div class="header-subtitle">
          Legs / Push / Pull / Core / Cardio / Flexibility → XP → Level 100 is max.
        </div>
      </div>
      <div class="header-settings card" style="padding:10px 12px; border-radius:14px;">
        <label for="bodyweightInput">Bodyweight (lb)</label>
        <input type="number" id="bodyweightInput" min="50" max="400" step="1" />
        <div class="muted" style="margin-top:2px;font-size:0.7rem;">
          Used to estimate load for bodyweight movements (push-ups, pull-ups, dips, etc).
        </div>
        <div id="cloudStatus" class="muted" style="margin-top:4px;font-size:0.7rem;"></div>
      </div>
    </div>

    <div class="grid">
      <!-- Left: plan + log -->
      <div class="card">
        <h2>Today&apos;s plan & log</h2>

        <!-- Plan / templates -->
        <div class="template-header">
          <div class="template-list-title">Pick a routine</div>
          <div class="template-hint muted">
            Choose a split, then tap an exercise to fill the form with your last values.
          </div>
        </div>
        <div class="row">
          <div>
            <label for="templateSelect">Workout template</label>
            <select id="templateSelect"></select>
          </div>
        </div>
        <div id="templateExercises" class="template-exercises"></div>

        <hr />

        <!-- Log form -->
        <form id="logForm">
          <div class="row">
            <div>
              <label for="dateInput">Date</label>
              <input type="date" id="dateInput" required />
            </div>
            <div>
              <label for="workoutInput">Workout name (optional)</label>
              <input type="text" id="workoutInput" placeholder="Chest & Tricep 1" />
            </div>
          </div>

          <div class="row">
            <div>
              <label for="skillInput">Skill</label>
              <select id="skillInput">
                <option value="Legs">Legs</option>
                <option value="Push">Push</option>
                <option value="Pull">Pull</option>
                <option value="Core">Core</option>
                <option value="Cardio">Cardio</option>
                <option value="Flexibility">Flexibility</option>
                <option value="Custom">Custom…</option>
              </select>
            </div>
            <div id="customSkillWrapper" style="display:none;">
              <label for="customSkillInput">Custom skill name</label>
              <input type="text" id="customSkillInput" placeholder="e.g. Mobility" />
            </div>
          </div>

          <!-- Strength / Flex row -->
          <div class="row" id="rowStrength">
            <div>
              <label for="setsInput">Sets</label>
              <input type="number" id="setsInput" min="1" step="1" />
            </div>
            <div>
              <label for="repsInput">Reps per set</label>
              <input type="number" id="repsInput" min="1" step="1" />
            </div>
            <div id="weightContainer">
              <label for="weightInput">Weight (lb)</label>
              <input type="number" id="weightInput" min="0" step="0.5" />
            </div>
          </div>

          <!-- Cardio row -->
          <div class="row" id="rowCardio" style="display:none;">
            <div>
              <label for="cardioModeSelect">Cardio input</label>
              <select id="cardioModeSelect">
                <option value="speed">Speed × time</option>
                <option value="distance">Distance × time</option>
              </select>
            </div>
            <div>
              <label id="cardioValueLabel" for="cardioValueInput">Speed (mph)</label>
              <input type="number" id="cardioValueInput" min="0" step="0.1" />
            </div>
            <div id="cardioTimeContainer">
              <label for="cardioMinutesInput">Time (minutes)</label>
              <input type="number" id="cardioMinutesInput" min="0" step="1" />
            </div>
          </div>

          <div class="row">
            <div>
              <label for="exerciseInput">Exercise</label>
              <input type="text" id="exerciseInput" placeholder="Bench press / Run" required />
            </div>
          </div>

          <div class="row">
            <div>
              <label>Volume (auto)</label>
              <input type="text" id="volumePreview" disabled />
            </div>
            <div>
              <label>XP (auto)</label>
              <input type="text" id="xpPreview" disabled />
            </div>
          </div>

          <div class="inline-buttons">
            <button type="submit">Add entry</button>
            <button type="button" class="secondary" id="clearAllBtn">Clear all data (local + server)</button>
          </div>
        </form>
      </div>

      <!-- Right: skills + history / stats -->
      <div class="card">
        <h2>Skills</h2>
        <div class="tabs">
          <button type="button" class="tab-btn active" id="tabOverviewBtn">Overview</button>
          <button type="button" class="tab-btn" id="tabStatsBtn">Stats</button>
        </div>

        <!-- Overview pane -->
        <div id="overviewPane">
          <div id="skillsContainer" class="skills-grid"></div>

          <h3 style="margin-top:16px; font-size:0.95rem;">Workout history</h3>
          <div id="historyWrapper" class="collapsed">
            <div id="historyContainer"></div>
            <div id="emptyState" class="muted" style="margin-top:4px;">
              No workouts logged yet.
            </div>
          </div>
          <button type="button" class="secondary" id="historyToggleBtn">Show all history</button>
        </div>

        <!-- Stats pane -->
        <div id="statsPane" style="display:none;">
          <h3 style="font-size:0.95rem; margin-bottom:6px;">Skill XP overview</h3>
          <div id="statsSkillBarsWrapper" style="margin-bottom:10px;">
            <svg id="statsSkillBars" viewBox="0 0 320 140" preserveAspectRatio="none" style="width:100%; height:140px;"></svg>
          </div>

          <h3 style="font-size:0.95rem; margin-bottom:6px;">Exercise progress</h3>
          <div class="row">
            <div>
              <label for="statsExerciseSelect">Exercise</label>
              <select id="statsExerciseSelect"></select>
            </div>
          </div>
          <div id="statsExerciseSummary" class="muted" style="margin-bottom:6px;"></div>
          <div id="statsChartWrapper">
            <svg id="statsVolumeChart" viewBox="0 0 320 140" preserveAspectRatio="none" style="width:100%; height:140px;"></svg>
          </div>
          <div id="statsTableWrapper" style="margin-top:8px;"></div>
        </div>
      </div>
    </div>
  </div>

<script>
  // ===== CONFIG =====
  const SERVER_URL = "https://script.google.com/macros/s/AKfycbzRn7xYTMPzIfJctWIaLGypQPuhJXnnEmhsuo5w32uSnEFuboM0HoauUUCE-ei9rCrS/exec";

  const LOCAL_ENTRIES_KEY = "workoutGrindEntries_v3";
  const LOCAL_SETTINGS_KEY = "workoutGrindSettings_v1";

  const MAX_LEVEL = 100;
  const XP_SCALE = 5; // tuned so L100 ~ long grind
  const BASE_XP_PER_MILE = 25;
  const REF_PACE_MIN_PER_MILE = 10; // reference pace for cardio intensity

  // ===== Templates =====
  const defaultTemplates = [
    {
      name: "Chest & Tricep 1",
      defaultSkill: "Push",
      exercises: [
        { name: "Bench press", prescription: "4x5x135" },
        { name: "Diamond push-ups", prescription: "3x10xBW" },
        { name: "Tricep pull downs", prescription: "3x10x7" },
        { name: "Lat push down", prescription: "3x10x3" },
        { name: "Hollow body negatives", prescription: "3x5xBW" },
        { name: "Delts/Floor T-Raise", prescription: "3x10x10" },
        { name: "Run", prescription: "cardio:6.5x15" },
        { name: "Static stretch worked muscles", prescription: "flex:3x10" }
      ]
    },
    {
      name: "Back & Bicep & Delt 1",
      defaultSkill: "Pull",
      exercises: [
        { name: "Pull ups", prescription: "3x10xBW" },
        { name: "Single arm rows", prescription: "3x10x50" },
        { name: "Upright trap row", prescription: "3x10x3" },
        { name: "Lateral raise machine", prescription: "3x10x1" },
        { name: "Rear delt machine", prescription: "3x10x2" },
        { name: "V-ups", prescription: "3x10xBW" },
        { name: "Run", prescription: "cardio:6.5x10" },
        { name: "Static stretch worked muscles", prescription: "flex:3x10" }
      ]
    },
    {
      name: "Legs & Glute 1",
      defaultSkill: "Legs",
      exercises: [
        { name: "Hip thrusts", prescription: "3x10x155" },
        { name: "Bulgarian squats", prescription: "3x10x30" },
        { name: "Dumbbell lunge", prescription: "3x10x30" },
        { name: "Cable kick back", prescription: "3x10x6" },
        { name: "Toe touch crunch", prescription: "3x25xBW" },
        { name: "Delts/Floor T-Raise", prescription: "3x10x10" },
        { name: "Run", prescription: "cardio:6.5x12.5" },
        { name: "Static stretch worked muscles", prescription: "flex:3x10" }
      ]
    },
    {
      name: "Chest & Tricep 2",
      defaultSkill: "Push",
      exercises: [
        { name: "Dips", prescription: "3x10xBW" },
        { name: "Dumbbell flies", prescription: "3x10x40" },
        { name: "Skullcrushers", prescription: "3x10x30" },
        { name: "Pec crossovers", prescription: "3x10x3" },
        { name: "Side crunch", prescription: "3x10xBW" },
        { name: "Delts/Floor T-Raise", prescription: "3x10x15" },
        { name: "Run", prescription: "cardio:6.5x10" },
        { name: "Static stretch worked muscles", prescription: "flex:3x10" }
      ]
    },
    {
      name: "Back & Bicep & Delt 2",
      defaultSkill: "Pull",
      exercises: [
        { name: "Chin ups", prescription: "3x5xBW" },
        { name: "Pull down bar", prescription: "3x10x110" },
        { name: "Face pulls", prescription: "3x10x55" },
        { name: "Curls", prescription: "3x10x25" },
        { name: "Rear shoulder dumbbell raises", prescription: "3x10x15" },
        { name: "Wipers", prescription: "3x10xBW" },
        { name: "Run", prescription: "cardio:6.5x5" },
        { name: "Static stretch worked muscles", prescription: "flex:3x10" }
      ]
    }
  ];

  // ===== Tiers =====
  function getTierInfo(level) {
    if (level >= 91) return { name: "Apex Predator", color: "#ef4444" };
    if (level >= 81) return { name: "Legend", color: "#fbbf24" };
    if (level >= 71) return { name: "Champion", color: "#ec4899" };
    if (level >= 61) return { name: "Master", color: "#a855f7" };
    if (level >= 51) return { name: "Diamond", color: "#2563eb" };
    if (level >= 41) return { name: "Platinum", color: "#22d3ee" };
    if (level >= 31) return { name: "Gold", color: "#facc15" };
    if (level >= 21) return { name: "Silver", color: "#9ca3af" };
    if (level >= 11) return { name: "Bronze", color: "#b45309" };
    return { name: "Rookie", color: "#92400e" };
  }

  // ===== Level curve =====
  function totalXpForLevel(level) {
    const n = Math.max(0, level - 1);
    return XP_SCALE * n * n;
  }

  function getLevelFromXp(xp) {
    let lvl = 1;
    for (let i = 2; i <= MAX_LEVEL; i++) {
      if (xp >= totalXpForLevel(i)) {
        lvl = i;
      } else {
        break;
      }
    }
    return lvl;
  }

  function inferSkillType(skillName) {
    const s = (skillName || "").toLowerCase();
    if (s === "cardio") return "cardio";
    if (s === "flexibility") return "flexibility";
    return "strength";
  }

  // ===== Storage =====
  function loadSettings() {
    try {
      const raw = localStorage.getItem(LOCAL_SETTINGS_KEY);
      if (!raw) return { bodyweight: 180 };
      const s = JSON.parse(raw);
      if (!s || typeof s !== "object") return { bodyweight: 180 };
      if (!s.bodyweight || s.bodyweight <= 0) s.bodyweight = 180;
      return s;
    } catch {
      return { bodyweight: 180 };
    }
  }

  function saveSettings(settings) {
    localStorage.setItem(LOCAL_SETTINGS_KEY, JSON.stringify(settings));
  }

  function loadEntriesLocal() {
    try {
      const raw = localStorage.getItem(LOCAL_ENTRIES_KEY);
      if (!raw) return [];
      const arr = JSON.parse(raw);
      return Array.isArray(arr) ? arr : [];
    } catch {
      return [];
    }
  }

  function saveEntriesLocal(entries) {
    localStorage.setItem(LOCAL_ENTRIES_KEY, JSON.stringify(entries));
  }

  function normalizeEntryFromServer(raw) {
    return {
      id: Number(raw.id) || Date.now(),
      date: raw.date || "",
      workout: raw.workout || "",
      skill: raw.skill || "",
      skillType: raw.skillType || inferSkillType(raw.skill),
      exercise: raw.exercise || "",
      sets: Number(raw.sets) || 0,
      reps: Number(raw.reps) || 0,
      weight: Number(raw.weight) || 0,
      speed: Number(raw.speed) || 0,
      minutes: Number(raw.minutes) || 0,
      volume: Number(raw.volume) || 0,
      xp: Number(raw.xp) || 0,
      cardioMode: raw.cardioMode || null
    };
  }

  async function fetchEntriesFromServer() {
    if (!SERVER_URL) return null;
    setCloudStatus("Cloud sync: connecting…");
    try {
      const res = await fetch(SERVER_URL + "?mode=list");
      if (!res.ok) throw new Error("Server error");
      const data = await res.json();
      if (!Array.isArray(data)) {
        setCloudStatus("Cloud sync: local only (bad data from server)");
        return null;
      }
      setCloudStatus("Cloud sync: connected");
      return data.map(normalizeEntryFromServer);
    } catch (err) {
      console.error(err);
      setCloudStatus("Cloud sync: local only (could not reach server)");
      return null;
    }
  }

  // ===== Server writes (use text/plain to dodge CORS preflight) =====
  async function saveEntryToServer(entry) {
    if (!SERVER_URL) return;
    try {
      const res = await fetch(SERVER_URL, {
        method: "POST",
        headers: { "Content-Type": "text/plain;charset=utf-8" },
        body: JSON.stringify({ mode: "add", entry })
      });
      if (!res.ok) {
        console.error("Server error when saving entry", res.status, await res.text());
        setCloudStatus("Cloud sync: error (server)");
      } else {
        setCloudStatus("Cloud sync: connected");
      }
    } catch (err) {
      console.error(err);
      setCloudStatus("Cloud sync: error (saving locally only)");
    }
  }

  async function clearServerEntries() {
    if (!SERVER_URL) return;
    try {
      const res = await fetch(SERVER_URL, {
        method: "POST",
        headers: { "Content-Type": "text/plain;charset=utf-8" },
        body: JSON.stringify({ mode: "clear" })
      });
      if (!res.ok) {
        console.error("Server error when clearing entries", res.status, await res.text());
        setCloudStatus("Cloud sync: error clearing server data");
      } else {
        setCloudStatus("Cloud sync: connected");
      }
    } catch (err) {
      console.error(err);
      setCloudStatus("Cloud sync: error clearing server data");
    }
  }

  function setCloudStatus(text) {
    if (cloudStatusEl) cloudStatusEl.textContent = text;
  }

  // ===== XP & volume =====
  function getSkillTypeFromSelectValue(val) {
    if (val === "Cardio") return "cardio";
    if (val === "Flexibility") return "flexibility";
    return "strength";
  }

  function estimateBodyweightLoad(exerciseName, bodyweight) {
    const name = (exerciseName || "").toLowerCase();
    if (name.includes("push-up") || name.includes("push up")) return bodyweight * 0.6;
    if (name.includes("pull up") || name.includes("chin up")) return bodyweight * 1.0;
    if (name.includes("dip")) return bodyweight * 0.9;
    if (name.includes("row")) return bodyweight * 0.7;
    return bodyweight * 0.7;
  }

  function computeVolumeAndXp(
    skillType,
    sets,
    reps,
    weight,
    speedOrDistance,
    minutes,
    exerciseName,
    bodyweight,
    cardioMode
  ) {
    let volume = 0;
    let xp = 0;

    if (skillType === "cardio") {
      const mode = cardioMode || "speed";
      let distanceMiles = 0;
      if (mode === "distance") {
        distanceMiles = speedOrDistance;
      } else {
        distanceMiles = speedOrDistance * (minutes / 60);
      }
      volume = distanceMiles;

      if (distanceMiles > 0) {
        let intensityMultiplier = 1;
        if (minutes > 0) {
          const pace = minutes / distanceMiles;
          let ratio = REF_PACE_MIN_PER_MILE / pace;
          if (!isFinite(ratio) || ratio <= 0) ratio = 1;
          intensityMultiplier = Math.sqrt(ratio);
          if (intensityMultiplier < 0.7) intensityMultiplier = 0.7;
          if (intensityMultiplier > 1.5) intensityMultiplier = 1.5;
        }
        xp = Math.round(distanceMiles * BASE_XP_PER_MILE * intensityMultiplier);
      } else {
        xp = 0;
      }
    } else if (skillType === "flexibility") {
      volume = sets * reps;
      xp = volume > 0 ? Math.round(volume * 0.2) : 0;
    } else {
      let effectiveWeight = weight;
      if (!effectiveWeight || effectiveWeight <= 0) {
        effectiveWeight = estimateBodyweightLoad(exerciseName, bodyweight);
      }
      volume = sets * reps * effectiveWeight;
      xp = volume > 0 ? Math.round(volume / 220) : 0;
    }
    return { volume, xp };
  }

  function recalcEntriesUsingCurrentFormulas(entriesArr) {
    for (const e of entriesArr) {
      const skillType = e.skillType || inferSkillType(e.skill);
      let cardioMode = e.cardioMode || null;
      if (skillType === "cardio") {
        if (!cardioMode) {
          if (e.minutes > 0 && e.speed > 0 && e.speed <= 30) {
            cardioMode = "speed";
          } else {
            cardioMode = "distance";
          }
        }
      }

      const { volume, xp } = computeVolumeAndXp(
        skillType,
        e.sets || 0,
        e.reps || 0,
        e.weight || 0,
        e.speed || 0,
        e.minutes || 0,
        e.exercise || "",
        settings.bodyweight,
        cardioMode
      );

      e.skillType = skillType;
      e.volume = volume;
      e.xp = xp;
      if (cardioMode && skillType === "cardio") e.cardioMode = cardioMode;
    }
  }

  // ===== Prescription parsers =====
  function parseStrengthPrescription(prescription) {
    if (!prescription) return null;
    const m = prescription.match(/^\s*(\d+)\s*x\s*(\d+)\s*x\s*([0-9.]+|BW)\s*$/i);
    if (!m) return null;
    const sets = parseInt(m[1], 10);
    const reps = parseInt(m[2], 10);
    let weight = null;
    if (m[3].toUpperCase() !== "BW") {
      weight = parseFloat(m[3]);
    }
    if (!Number.isFinite(sets) || !Number.isFinite(reps)) return null;
    return { sets, reps, weight };
  }

  function parseCardioPrescription(prescription) {
    if (!prescription || !prescription.startsWith("cardio:")) return null;
    const rest = prescription.slice(7);
    const m = rest.match(/^\s*([0-9.]+)\s*x\s*([0-9.]+)\s*$/);
    if (!m) return null;
    const speed = parseFloat(m[1]);
    const minutes = parseFloat(m[2]);
    if (!Number.isFinite(speed) || !Number.isFinite(minutes)) return null;
    return { speed, minutes };
  }

  function parseFlexPrescription(prescription) {
    if (!prescription || !prescription.startsWith("flex:")) return null;
    const rest = prescription.slice(5);
    const m = rest.match(/^\s*(\d+)\s*x\s*(\d+)\s*$/);
    if (!m) return null;
    const sets = parseInt(m[1], 10);
    const reps = parseInt(m[2], 10);
    if (!Number.isFinite(sets) || !Number.isFinite(reps)) return null;
    return { sets, reps };
  }

function formatEntryDetails(e) {
  if (!e) return "";

  if (e.skillType === "cardio") {
    const mode = e.cardioMode || (e.minutes > 0 ? "speed" : "distance");
    if (e.minutes > 0) {
      if (mode === "distance") {
        return `${e.speed} mi in ${e.minutes} min`;
      }
      return `${e.speed} mph × ${e.minutes} min`;
    }
    if (mode === "distance") {
      return `${e.speed} mi`;
    }
    return `${e.speed} mph`;
  }

  if (e.skillType === "flexibility") {
    return `${e.sets} × ${e.reps}`;
  }

  // strength
  if (e.weight > 0) {
    return `${e.sets} × ${e.reps} × ${e.weight}`;
  }

  // Treat 0/blank weight as bodyweight
  return `${e.sets} × ${e.reps} × BW`;
}

  // ===== DOM refs =====
  const dateInput = document.getElementById("dateInput");
  const workoutInput = document.getElementById("workoutInput");
  const skillInput = document.getElementById("skillInput");
  const customSkillWrapper = document.getElementById("customSkillWrapper");
  const customSkillInput = document.getElementById("customSkillInput");
  const setsInput = document.getElementById("setsInput");
  const repsInput = document.getElementById("repsInput");
  const weightInput = document.getElementById("weightInput");
  const weightContainer = document.getElementById("weightContainer");

  const rowStrength = document.getElementById("rowStrength");
  const rowCardio = document.getElementById("rowCardio");
  const cardioModeSelect = document.getElementById("cardioModeSelect");
  const cardioValueLabel = document.getElementById("cardioValueLabel");
  const cardioValueInput = document.getElementById("cardioValueInput");
  const cardioMinutesInput = document.getElementById("cardioMinutesInput");
  const cardioTimeContainer = document.getElementById("cardioTimeContainer");

  const exerciseInput = document.getElementById("exerciseInput");
  const volumePreview = document.getElementById("volumePreview");
  const xpPreview = document.getElementById("xpPreview");
  const logForm = document.getElementById("logForm");
  const skillsContainer = document.getElementById("skillsContainer");
  const historyWrapper = document.getElementById("historyWrapper");
  const historyContainer = document.getElementById("historyContainer");
  const historyToggleBtn = document.getElementById("historyToggleBtn");
  const emptyState = document.getElementById("emptyState");
  const clearAllBtn = document.getElementById("clearAllBtn");
  const templateSelect = document.getElementById("templateSelect");
  const templateExercisesDiv = document.getElementById("templateExercises");
  const bodyweightInput = document.getElementById("bodyweightInput");
  const cloudStatusEl = document.getElementById("cloudStatus");

  const tabOverviewBtn = document.getElementById("tabOverviewBtn");
  const tabStatsBtn = document.getElementById("tabStatsBtn");
  const overviewPane = document.getElementById("overviewPane");
  const statsPane = document.getElementById("statsPane");
  const statsExerciseSelect = document.getElementById("statsExerciseSelect");
  const statsExerciseSummary = document.getElementById("statsExerciseSummary");
  const statsVolumeChart = document.getElementById("statsVolumeChart");
  const statsTableWrapper = document.getElementById("statsTableWrapper");
  const statsSkillBars = document.getElementById("statsSkillBars");

  // ===== runtime state =====
  const entries = [];
  let lastByExercise = {};
  let settings = loadSettings();
  let prevSkillTotals = {};
  let prevSkillLevels = {};
  let hasRenderedSkillsOnce = false;
  let historyExpanded = false;

  dateInput.valueAsNumber = Date.now() - new Date().getTimezoneOffset() * 60000;

  bodyweightInput.value = settings.bodyweight;
  bodyweightInput.addEventListener("input", () => {
    const v = parseFloat(bodyweightInput.value);
    if (Number.isFinite(v) && v > 0) {
      settings.bodyweight = v;
      saveSettings(settings);
    }
  });

  if (!SERVER_URL) {
    setCloudStatus("Cloud sync: off (local only)");
  }

  function rebuildLastByExercise() {
    lastByExercise = {};
    const sorted = [...entries].sort((a, b) => (a.date > b.date ? 1 : -1));
    for (const e of sorted) {
      const key = (e.exercise || "").toLowerCase();
      if (!key) continue;
      lastByExercise[key] = e;
    }
  }

  function getEffectiveSkillName() {
    let skill = skillInput.value;
    if (skill === "Custom") {
      const c = customSkillInput.value.trim();
      if (c) skill = c;
    }
    return skill;
  }

  function getCurrentSkillType() {
    return getSkillTypeFromSelectValue(skillInput.value);
  }

  function setSkillFromEntry(entry) {
    const opts = Array.from(skillInput.options).map(o => o.value);
    if (opts.includes(entry.skill)) {
      skillInput.value = entry.skill;
      customSkillInput.value = "";
    } else {
      skillInput.value = "Custom";
      customSkillInput.value = entry.skill || "";
    }
    updateSkillModeUI();
  }

  function updateSkillModeUI() {
    const val = skillInput.value;
    const type = getSkillTypeFromSelectValue(val);

    if (val === "Custom") {
      customSkillWrapper.style.display = "block";
    } else {
      customSkillWrapper.style.display = "none";
    }

    if (type === "cardio") {
      rowStrength.style.display = "none";
      rowCardio.style.display = "flex";
      cardioModeSelect.value = "speed";
      cardioValueLabel.textContent = "Speed (mph)";
      cardioTimeContainer.style.display = "block";
    } else {
      rowStrength.style.display = "flex";
      rowCardio.style.display = "none";
    }

    if (type === "flexibility") {
      weightContainer.style.display = "none";
    } else {
      weightContainer.style.display = "block";
    }
  }

  function updateCardioModeUI() {
    const mode = cardioModeSelect.value;
    if (mode === "distance") {
      cardioValueLabel.textContent = "Distance (miles)";
    } else {
      cardioValueLabel.textContent = "Speed (mph)";
    }
    cardioTimeContainer.style.display = "block";
    updatePreview();
  }

  cardioModeSelect.addEventListener("change", updateCardioModeUI);

  function updatePreview() {
    const type = getCurrentSkillType();
    let sets = 0, reps = 0, weight = 0, speedOrDistance = 0, minutes = 0;
    const cardioMode = cardioModeSelect.value;

    if (type === "cardio") {
      speedOrDistance = parseFloat(cardioValueInput.value) || 0;
      minutes = parseFloat(cardioMinutesInput.value) || 0;
    } else {
      sets = parseFloat(setsInput.value) || 0;
      reps = parseFloat(repsInput.value) || 0;
      if (type === "strength") {
        weight = parseFloat(weightInput.value) || 0;
      }
    }

    const { volume, xp } = computeVolumeAndXp(
      type,
      sets,
      reps,
      weight,
      speedOrDistance,
      minutes,
      exerciseInput.value,
      settings.bodyweight,
      cardioMode
    );
    volumePreview.value = volume > 0 ? volume.toFixed(2) : "";
    xpPreview.value = xp > 0 ? xp.toString() : "";
  }

  skillInput.addEventListener("change", () => {
    updateSkillModeUI();
    updatePreview();
  });

  [setsInput, repsInput, weightInput, cardioValueInput, cardioMinutesInput, exerciseInput].forEach(el => {
    el.addEventListener("input", updatePreview);
  });

  function groupBySkill(entriesArr) {
    const map = new Map();
    for (const e of entriesArr) {
      const skill = e.skill || "Unknown";
      if (!map.has(skill)) {
        map.set(skill, { skill, totalXp: 0, totalVolume: 0, count: 0 });
      }
      const obj = map.get(skill);
      obj.totalXp += e.xp || 0;
      obj.totalVolume += e.volume || 0;
      obj.count += 1;
    }
    return Array.from(map.values());
  }

  function renderSkills() {
    const groups = groupBySkill(entries);
    skillsContainer.innerHTML = "";

    if (!groups.length) {
      skillsContainer.innerHTML = '<div class="muted">Log a workout to start gaining XP.</div>';
      prevSkillTotals = {};
      prevSkillLevels = {};
      hasRenderedSkillsOnce = true;
      return;
    }

    const newTotals = {};
    const newLevels = {};

    groups.sort((a, b) => b.totalXp - a.totalXp);

    for (const g of groups) {
      const level = getLevelFromXp(g.totalXp);
      newTotals[g.skill] = g.totalXp;
      newLevels[g.skill] = level;

      const tier = getTierInfo(level);

      const xpCurrent = totalXpForLevel(level);
      const xpNext = totalXpForLevel(Math.min(level + 1, MAX_LEVEL));
      const xpInto = g.totalXp - xpCurrent;
      const xpNeeded = Math.max(1, xpNext - xpCurrent);
      const pct = Math.min(100, Math.max(0, (xpInto / xpNeeded) * 100));

      const prevXp = prevSkillTotals[g.skill] || 0;
      const prevLevel = prevSkillLevels[g.skill] || 1;
      const prevCurrent = totalXpForLevel(prevLevel);
      const prevNext = totalXpForLevel(Math.min(prevLevel + 1, MAX_LEVEL));
      let prevPct = 0;
      if (prevNext > prevCurrent) {
        prevPct = Math.min(
          100,
          Math.max(0, ((prevXp - prevCurrent) / (prevNext - prevCurrent)) * 100)
        );
      }

      const div = document.createElement("div");
      div.className = "skill-card";
      div.innerHTML = `
        <div class="skill-header">
          <div class="skill-name">
            ${g.skill}
            <span class="tier-pill">${tier.name}</span>
          </div>
          <div class="skill-level">Lvl ${level}</div>
        </div>
        <div class="skill-xp">
          ${g.totalXp.toLocaleString()} XP · ${xpInto.toLocaleString()} / ${xpNeeded.toLocaleString()} to next
        </div>
        <div class="progress-bar">
          <div class="progress-fill"></div>
        </div>
        <div class="muted" style="margin-top:4px;">
          ${g.count} entries · total volume ${g.totalVolume.toFixed(0)}
        </div>
      `;
      skillsContainer.appendChild(div);

      div.style.borderColor = tier.color + "80";
      const pill = div.querySelector(".tier-pill");
      pill.style.borderColor = tier.color;
      pill.style.color = tier.color;

      const fill = div.querySelector(".progress-fill");
      fill.style.background = `linear-gradient(to right, ${tier.color}, #0f172a)`;
      const levelEl = div.querySelector(".skill-level");

      if (!hasRenderedSkillsOnce) {
        fill.style.width = pct.toFixed(1) + "%";
      } else {
        fill.style.width = prevPct.toFixed(1) + "%";
        requestAnimationFrame(() => {
          fill.style.width = pct.toFixed(1) + "%";
        });
      }

      if (hasRenderedSkillsOnce && level > prevLevel) {
        levelEl.classList.add("skill-level-pop");
        setTimeout(() => levelEl.classList.remove("skill-level-pop"), 900);
      }
    }

    prevSkillTotals = newTotals;
    prevSkillLevels = newLevels;
    hasRenderedSkillsOnce = true;
  }

  function niceDateLabel(dateStr) {
    if (!dateStr) return "";
    const parts = dateStr.split("-");
    if (parts.length !== 3) return dateStr;
    const year = parseInt(parts[0], 10);
    const month = parseInt(parts[1], 10);
    const day = parseInt(parts[2], 10);
    if (!year || !month || !day) return dateStr;
    const d = new Date(year, month - 1, day);
    return d.toLocaleDateString(undefined, { weekday: "short", month: "short", day: "numeric" });
  }

  function updateHistoryToggle() {
    if (!entries.length) {
      historyWrapper.classList.remove("collapsed", "expanded");
      historyToggleBtn.style.display = "none";
      return;
    }
    historyToggleBtn.style.display = "inline-block";
    if (historyExpanded) {
      historyWrapper.classList.add("expanded");
      historyWrapper.classList.remove("collapsed");
      historyToggleBtn.textContent = "Collapse history";
    } else {
      historyWrapper.classList.add("collapsed");
      historyWrapper.classList.remove("expanded");
      historyToggleBtn.textContent = "Show all history";
    }
  }

  historyToggleBtn.addEventListener("click", () => {
    historyExpanded = !historyExpanded;
    updateHistoryToggle();
  });

  function renderHistory() {
    historyContainer.innerHTML = "";

    if (!entries.length) {
      emptyState.style.display = "block";
      updateHistoryToggle();
      return;
    }
    emptyState.style.display = "none";

    const byDate = new Map();
    for (const e of entries) {
      const key = e.date || "";
      if (!byDate.has(key)) byDate.set(key, []);
      byDate.get(key).push(e);
    }

    const dates = Array.from(byDate.keys()).sort((a, b) => (a < b ? 1 : -1));

    for (const date of dates) {
      const list = byDate.get(date);
      const dayDiv = document.createElement("div");
      dayDiv.className = "history-day";

      const totalXp = list.reduce((s, e) => s + (e.xp || 0), 0);

      dayDiv.innerHTML = `
        <div class="history-day-header">
          <div class="history-day-title">${niceDateLabel(date)}</div>
          <div class="history-day-sub">${totalXp.toLocaleString()} XP · ${list.length} entries</div>
        </div>
      `;

      list.sort((a, b) => (a.skill > b.skill ? 1 : -1));

      for (const e of list) {
        const row = document.createElement("div");
        row.className = "history-entry";
        row.innerHTML = `
          <div class="history-entry-main">
            <span class="tag">${e.skill}</span>
            &nbsp;${e.exercise}
            <span class="muted">(${formatEntryDetails(e)})</span>
          </div>
          <div class="history-entry-extra">
            Vol ${e.volume.toFixed(2)} · ${e.xp.toLocaleString()} XP
          </div>
        `;
        dayDiv.appendChild(row);
      }

      historyContainer.appendChild(dayDiv);
    }

    updateHistoryToggle();
  }

  function drawSkillXpBars(skillGroups) {
    const svg = statsSkillBars;
    if (!svg) return;
    svg.innerHTML = "";

    if (!skillGroups.length) return;

    const groups = skillGroups.slice().sort((a, b) => b.totalXp - a.totalXp);

    const width = 320;
    const height = 140;
    const paddingLeft = 40;
    const paddingRight = 10;
    const paddingTop = 10;
    const paddingBottom = 30;

    const plotWidth = width - paddingLeft - paddingRight;
    const plotHeight = height - paddingTop - paddingBottom;

    const maxXp = Math.max(...groups.map(g => g.totalXp));
    if (maxXp <= 0) return;

    const barSlotWidth = plotWidth / groups.length;
    const barWidth = Math.max(12, barSlotWidth * 0.6);

    const ns = "http://www.w3.org/2000/svg";

    const axis = document.createElementNS(ns, "line");
    axis.setAttribute("x1", paddingLeft);
    axis.setAttribute("y1", height - paddingBottom);
    axis.setAttribute("x2", width - paddingRight);
    axis.setAttribute("y2", height - paddingBottom);
    axis.setAttribute("stroke", "#1f2937");
    axis.setAttribute("stroke-width", "1");
    svg.appendChild(axis);

    groups.forEach((g, i) => {
      const centerX = paddingLeft + barSlotWidth * (i + 0.5);
      const ratio = g.totalXp / maxXp;
      const barHeight = plotHeight * ratio;
      const x = centerX - barWidth / 2;
      const y = height - paddingBottom - barHeight;

      const tier = getTierInfo(getLevelFromXp(g.totalXp));

      const rect = document.createElementNS(ns, "rect");
      rect.setAttribute("x", x);
      rect.setAttribute("y", y);
      rect.setAttribute("width", barWidth);
      rect.setAttribute("height", barHeight);
      rect.setAttribute("rx", "4");
      rect.setAttribute("fill", tier.color);
      svg.appendChild(rect);

      const xpLabel = document.createElementNS(ns, "text");
      xpLabel.setAttribute("x", centerX);
      xpLabel.setAttribute("y", y - 4);
      xpLabel.setAttribute("text-anchor", "middle");
      xpLabel.setAttribute("font-size", "8");
      xpLabel.setAttribute("fill", "#9ca3af");
      xpLabel.textContent = Math.round(g.totalXp).toLocaleString();
      svg.appendChild(xpLabel);

      const nameLabel = document.createElementNS(ns, "text");
      nameLabel.setAttribute("x", centerX);
      nameLabel.setAttribute("y", height - paddingBottom + 12);
      nameLabel.setAttribute("text-anchor", "middle");
      nameLabel.setAttribute("font-size", "8");
      nameLabel.setAttribute("fill", "#9ca3af");
      const shortName = g.skill.length > 8 ? g.skill.slice(0, 7) + "…" : g.skill;
      nameLabel.textContent = shortName;
      svg.appendChild(nameLabel);
    });
  }

  function renderStatsPanel() {
    const skillGroups = groupBySkill(entries);
    drawSkillXpBars(skillGroups);

    const exercises = Array.from(
      new Set(entries.map(e => e.exercise).filter(Boolean))
    ).sort((a, b) => a.localeCompare(b));

    statsExerciseSelect.innerHTML = "";
    if (!exercises.length) {
      statsExerciseSelect.innerHTML = '<option value="">No data yet</option>';
      statsExerciseSummary.textContent = "Log some workouts to see progress.";
      statsVolumeChart.innerHTML = "";
      statsTableWrapper.innerHTML = "";
      return;
    }

    let selected = statsExerciseSelect.value;
    if (!selected || !exercises.includes(selected)) {
      selected = exercises[0];
    }

    exercises.forEach(name => {
      const opt = document.createElement("option");
      opt.value = name;
      opt.textContent = name;
      if (name === selected) opt.selected = true;
      statsExerciseSelect.appendChild(opt);
    });

    renderStatsForExercise(selected);
  }

  statsExerciseSelect.addEventListener("change", () => {
    const name = statsExerciseSelect.value;
    if (name) renderStatsForExercise(name);
  });

  function renderStatsForExercise(name) {
    const filtered = entries.filter(e => e.exercise === name);
    if (!filtered.length) {
      statsExerciseSummary.textContent = "No logs yet.";
      statsVolumeChart.innerHTML = "";
      statsTableWrapper.innerHTML = "";
      return;
    }

    filtered.sort((a, b) => (a.date > b.date ? 1 : -1));

    const firstDate = filtered[0].date;
    const lastDate = filtered[filtered.length - 1].date;
    const lastEntry = filtered[filtered.length - 1];

    statsExerciseSummary.textContent =
      `From ${niceDateLabel(firstDate)} to ${niceDateLabel(lastDate)} · ` +
      `Last volume ${lastEntry.volume.toFixed(2)} (${formatEntryDetails(lastEntry)})`;

    const byDate = new Map();
    for (const e of filtered) {
      const key = e.date || "";
      byDate.set(key, (byDate.get(key) || 0) + e.volume);
    }
    const orderedDates = Array.from(byDate.keys()).sort();
    const series = orderedDates.map(d => ({ date: d, volume: byDate.get(d) }));

    drawVolumeChart(series);
    renderStatsTable(filtered);
  }

  function drawVolumeChart(series) {
    const svg = statsVolumeChart;
    svg.innerHTML = "";
    if (!series.length) return;

    const width = 320;
    const height = 140;
    const paddingLeft = 24;
    const paddingRight = 4;
    const paddingTop = 10;
    const paddingBottom = 20;

    const plotWidth = width - paddingLeft - paddingRight;
    const plotHeight = height - paddingTop - paddingBottom;

    const maxVol = Math.max(...series.map(p => p.volume));
    const minVol = 0;

    const points = series.map((p, idx) => {
      const x =
        paddingLeft +
        (series.length === 1 ? plotWidth / 2 : (plotWidth * idx) / (series.length - 1));
      const ratio = (p.volume - minVol) / (maxVol - minVol || 1);
      const y = paddingTop + (plotHeight * (1 - ratio));
      return { x, y, date: p.date, volume: p.volume };
    });

    const ns = "http://www.w3.org/2000/svg";

    const axis = document.createElementNS(ns, "line");
    axis.setAttribute("x1", paddingLeft);
    axis.setAttribute("y1", height - paddingBottom);
    axis.setAttribute("x2", width - paddingRight);
    axis.setAttribute("y2", height - paddingBottom);
    axis.setAttribute("stroke", "#1f2937");
    axis.setAttribute("stroke-width", "1");
    svg.appendChild(axis);

    let pathD = "";
    points.forEach((pt, i) => {
      pathD += (i === 0 ? "M" : "L") + pt.x + " " + pt.y + " ";
    });
    const path = document.createElementNS(ns, "path");
    path.setAttribute("d", pathD);
    path.setAttribute("fill", "none");
    path.setAttribute("stroke", "#22c55e");
    path.setAttribute("stroke-width", "2");
    svg.appendChild(path);

    points.forEach(pt => {
      const c = document.createElementNS(ns, "circle");
      c.setAttribute("cx", pt.x);
      c.setAttribute("cy", pt.y);
      c.setAttribute("r", "3");
      c.setAttribute("fill", "#38bdf8");
      svg.appendChild(c);
    });
  }

  function renderStatsTable(filtered) {
    const container = statsTableWrapper;
    container.innerHTML = "";
    if (!filtered.length) {
      container.innerHTML = '<div class="muted">No logs yet.</div>';
      return;
    }

    const tbl = document.createElement("table");
    const thead = document.createElement("thead");
    thead.innerHTML =
      "<tr><th>Date</th><th>Skill</th><th>Details</th><th>Volume</th><th>XP</th></tr>";
    const tbody = document.createElement("tbody");

    filtered.forEach(e => {
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${niceDateLabel(e.date)}</td>
        <td>${e.skill}</td>
        <td>${formatEntryDetails(e)}</td>
        <td>${e.volume.toFixed(2)}</td>
        <td>${e.xp.toLocaleString()}</td>
      `;
      tbody.appendChild(tr);
    });

    tbl.appendChild(thead);
    tbl.appendChild(tbody);
    container.appendChild(tbl);
  }

  function renderAll() {
    rebuildLastByExercise();
    renderSkills();
    renderHistory();
    renderTemplateExercises(templateSelect.value || "");
    renderStatsPanel();
  }

  function fillFromTemplateExercise(tpl, ex) {
    workoutInput.value = tpl.name;
    exerciseInput.value = ex.name || "";

    setsInput.value = "";
    repsInput.value = "";
    weightInput.value = "";
    cardioValueInput.value = "";
    cardioMinutesInput.value = "";

    const key = (ex.name || "").toLowerCase();
    const last = lastByExercise[key];

    if (last) {
      setSkillFromEntry(last);
      setsInput.value = last.sets || "";
      repsInput.value = last.reps || "";
      weightInput.value = last.weight || "";
      cardioValueInput.value = last.speed || "";
      cardioMinutesInput.value = last.minutes || "";
      if (last.skillType === "cardio") {
        const mode = last.cardioMode || (last.minutes > 0 && last.speed > 0 ? "speed" : "distance");
        cardioModeSelect.value = mode;
        updateCardioModeUI();
      }
    } else {
      skillInput.value = tpl.defaultSkill || "Push";
      updateSkillModeUI();
      const pres = ex.prescription || "";
      if (pres.startsWith("cardio:")) {
        skillInput.value = "Cardio";
        updateSkillModeUI();
        const c = parseCardioPrescription(pres);
        if (c) {
          cardioModeSelect.value = "speed";
          updateCardioModeUI();
          cardioValueInput.value = c.speed.toString();
          cardioMinutesInput.value = c.minutes.toString();
        }
      } else if (pres.startsWith("flex:")) {
        skillInput.value = "Flexibility";
        updateSkillModeUI();
        const f = parseFlexPrescription(pres);
        if (f) {
          setsInput.value = f.sets.toString();
          repsInput.value = f.reps.toString();
        }
      } else {
        const s = parseStrengthPrescription(pres);
        if (s) {
          setsInput.value = s.sets.toString();
          repsInput.value = s.reps.toString();
          if (s.weight != null) {
            weightInput.value = s.weight.toString();
          }
        }
      }
    }

    updatePreview();
    exerciseInput.focus();
  }

  function renderTemplateExercises(index) {
    if (index === "" || index == null) {
      templateExercisesDiv.innerHTML = '<div class="muted">Select a routine above.</div>';
      return;
    }
    const idx = parseInt(index, 10);
    const tpl = defaultTemplates[idx];
    if (!tpl || !tpl.exercises || !tpl.exercises.length) {
      templateExercisesDiv.innerHTML = '<div class="muted">No exercises defined for this routine yet.</div>';
      return;
    }
    templateExercisesDiv.innerHTML = "";

    tpl.exercises.forEach(ex => {
      const card = document.createElement("div");
      card.className = "template-card";

      const key = (ex.name || "").toLowerCase();
      const last = lastByExercise[key];
      const lastText = last
        ? `Last: ${formatEntryDetails(last)} (${last.date})`
        : "No log yet";

      card.innerHTML = `
        <div><strong>${ex.name}</strong></div>
        <div class="template-prescription">Template: ${ex.prescription || ""}</div>
        <div class="template-last">${lastText}</div>
        <button type="button" class="template-use-btn">Use in form</button>
      `;
      const btn = card.querySelector("button");
      btn.addEventListener("click", () => fillFromTemplateExercise(tpl, ex));
      templateExercisesDiv.appendChild(card);
    });
  }

  function initTemplates() {
    templateSelect.innerHTML = '<option value="">Pick a routine…</option>';
    defaultTemplates.forEach((tpl, idx) => {
      const opt = document.createElement("option");
      opt.value = String(idx);
      opt.textContent = tpl.name;
      templateSelect.appendChild(opt);
    });
    templateSelect.addEventListener("change", () => {
      renderTemplateExercises(templateSelect.value);
    });
    renderTemplateExercises("");
  }

  tabOverviewBtn.addEventListener("click", () => {
    tabOverviewBtn.classList.add("active");
    tabStatsBtn.classList.remove("active");
    overviewPane.style.display = "block";
    statsPane.style.display = "none";
  });

  tabStatsBtn.addEventListener("click", () => {
    tabStatsBtn.classList.add("active");
    tabOverviewBtn.classList.remove("active");
    overviewPane.style.display = "none";
    statsPane.style.display = "block";
    renderStatsPanel();
  });

  logForm.addEventListener("submit", async (e) => {
    e.preventDefault();
    const date = dateInput.value;
    const workout = workoutInput.value.trim();
    const skillName = getEffectiveSkillName();
    const skillType = getCurrentSkillType();
    const exercise = exerciseInput.value.trim();

    let sets = 0, reps = 0, weight = 0, speedOrDistance = 0, minutes = 0;
    const cardioMode = cardioModeSelect.value;

    if (!date || !exercise) {
      alert("Please fill date and exercise.");
      return;
    }

    if (skillType === "cardio") {
      speedOrDistance = parseFloat(cardioValueInput.value) || 0;
      minutes = parseFloat(cardioMinutesInput.value) || 0;

      if (cardioMode === "speed") {
        if (speedOrDistance <= 0 || minutes <= 0) {
          alert("Fill speed (mph) and minutes for cardio.");
          return;
        }
      } else {
        if (speedOrDistance <= 0 || minutes <= 0) {
          alert("Fill distance (miles) and minutes for cardio.");
          return;
        }
      }
    } else {
      sets = parseInt(setsInput.value, 10) || 0;
      reps = parseInt(repsInput.value, 10) || 0;
      if (sets <= 0 || reps <= 0) {
        alert("Fill sets and reps.");
        return;
      }
      if (skillType === "strength") {
        weight = parseFloat(weightInput.value) || 0;
        if (weight < 0) {
          alert("Weight cannot be negative.");
          return;
        }
      }
    }

    const { volume, xp } = computeVolumeAndXp(
      skillType,
      sets,
      reps,
      weight,
      speedOrDistance,
      minutes,
      exercise,
      settings.bodyweight,
      cardioMode
    );

    const entry = {
      id: Date.now(),
      date,
      workout,
      skill: skillName,
      skillType,
      exercise,
      sets,
      reps,
      weight,
      speed: speedOrDistance,
      minutes,
      volume,
      xp,
      cardioMode: skillType === "cardio" ? cardioMode : null
    };

    entries.push(entry);
    saveEntriesLocal(entries);
    saveEntryToServer(entry);
    renderAll();

    exerciseInput.value = "";
    setsInput.value = "";
    repsInput.value = "";
    weightInput.value = "";
    cardioValueInput.value = "";
    cardioMinutesInput.value = "";
    volumePreview.value = "";
    xpPreview.value = "";
  });

  clearAllBtn.addEventListener("click", async () => {
    if (!confirm("Clear all local data and (if configured) server data?")) return;
    entries.splice(0, entries.length);
    saveEntriesLocal(entries);
    await clearServerEntries();
    renderAll();
  });

  // ===== Init =====
  async function initApp() {
    updateSkillModeUI();
    updateCardioModeUI();
    initTemplates();

    const local = loadEntriesLocal();
    let loaded = [];
    const server = await fetchEntriesFromServer();

    if (server === null) {
      if (SERVER_URL) {
        setCloudStatus("Cloud sync: local only (could not reach server)");
      }
      loaded = local;
    } else if (server.length === 0 && local.length > 0) {
      loaded = local;
      setCloudStatus("Cloud sync: connected (using local history)");
    } else {
      loaded = server;
      if (!server.length) {
        setCloudStatus("Cloud sync: connected (no rows yet)");
      }
    }

    entries.splice(0, entries.length, ...loaded);
    recalcEntriesUsingCurrentFormulas(entries);
    renderAll();
  }

  initApp();
</script>
</body>
</html>

